\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{enumitem}  

\title{Leetcode Notes and Practice}
\author{Sebastian Pucher}

\begin{document}
\maketitle                             


\tableofcontents

\newpage

\section{Hashing}
\subsection{Valid Anagram}
\begin{enumerate}
  \item[] \textbf{Question:} Given two strings s and t, return true if the two strings are anagrams of each other, otherwise return false
    \begin{enumerate}
      \item[-] Create two separate dictionaries
      \item[-] Loop through one of the input strings, add key letter or letter freq.
      \item[-] If dict are the same, return true
    \end{enumerate}
\end{enumerate}

\subsection{Twosum}
\begin{enumerate}
  \item[] \textbf{Question:} Given an array of integers nums and an integer target, return the indices i and j such that nums[i] + nums[j] == target and i != j
    \begin{enumerate}
      \item[-] Use a hashmap to store the index of each number in the array as the \textit{value}
      \item[-] On each iteration, check first to see if the difference between the target val and the current num is already stored in the hashmap
      \item[-] If it is, then return the value at that key (the index), as well as the current index i
      \item[-] If it's not, then add the current number and index to the hashmap 
      \item[-] \textbf{Key Idea: } Always check the existence between the target and the current number as a key in the hashmap first!
    \end{enumerate}
\end{enumerate}

\subsection{Group Anagram}
\begin{enumerate}
  \item[] \textbf{Question:} Given an array of strings strs, group all anagrams together into sublists. You may return the output in any order.

An anagram is a string that contains the exact same characters as another string, but the order of the characters can be different.

    \begin{enumerate}
      \item[-] The main idea of this question is to use a hashmap, and use arrays as keys. In this case, the array would have 26 elements, set to 0 to start. 
      \item[-] Each of the 26 elements represents a letter a-z. The idea is that you count each letter when traversing through the string.  
      \item[-] Once you have counted all the letters, use tupple() to change the mutable array into an immutable key that can be used to store the word.
      \item[-] When adding it to the hash, first check to see if the key already exists. If so, add it to the array of other strs that have that mapping (add it to the values array at that key)
      \item[-] If it's not a key, add it as a new key, and add the string as an element of an array to the value at that position. 
      \item[-] Return the values of the hashmap. 
    \end{enumerate}
\end{enumerate}


\subsection{Single Number}
\begin{enumerate}
  \item[] \textbf{Question:} You are given a non-empty array of integers nums. Every integer appears twice except for one.

Return the integer that appears only once.

You must implement a solution with O(n) runtime complexity and use only  O(1) extra space. 


    \begin{enumerate}
      \item[-] Use a hash to keep track of numbers
      \item[-] If a number is not in the hash, add it in, if it is already in, then remove it.  
      \item[-] If you repeat this process for every number, then the only value left when you've traversed through the whole array will be the single number: So return the only key left
    \end{enumerate}
\end{enumerate}




\section{Two Pointers}
\subsection{Valid Palindrome}
\begin{enumerate}
  \item[] \textbf{Question:} Given a string s, return true if it is a palindrome, otherwise return false.

A palindrome is a string that reads the same forward and backward. It is also case-insensitive and ignores all non-alphanumeric characters.
    \begin{enumerate}
      \item[-] First change the string to all lowercase with .lower() function, this ensures case sensitive args are taken care of
      \item[-] Init left and right pointers to first and last characters
      \item[-] Do a check using \textbf{.isalnum()}. If it is \textit{not} alpha numeric, then increment or decrement the pointer and \textit{continue} through the loop
      \item[-] While left is less than or equal two right, compare the letters, if not the same, return false
      \item[-] increment / decrement left and right at bottom of loop
    \end{enumerate}
\end{enumerate}


\subsection{Two Sum II (Two Integer Sum)}
\begin{enumerate}
  \item[] \textbf{Question:} Given an array of integers numbers that is sorted in non-decreasing order.

Return the indices (1-indexed) of two numbers, [index1, index2], such that they add up to a given target number target and index1 < index2. Note that index1 and index2 cannot be equal, therefore you may not use the same element twice.

There will always be exactly one valid solution.

Your solution must use O(1) additional space.
    \begin{enumerate}
      \item[-] \textbf{Main idea: } Use two pointers, one at the beginning of the array, and one at the end
      \item[-] If the sum number at the two pointers added together is greater than the target, then this means that the current sum is two big, and we must \textit{decrement the right pointer}
      \item[-] Following this same logic, if the current sum between the two pointers is less than the target, then we must \textit{increment the left pointer}. 
      \item[-] Do this until sum == target, then return.
    \end{enumerate}
\end{enumerate}



\section{Sliding Window}
\subsection{Best Time to Buy and Sell Stocks}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an integer array prices where prices[i] is the price of NeetCoin on the ith day.

You may choose a single day to buy one NeetCoin and choose a different day in the future to sell it.

Return the maximum profit you can achieve. You may choose to not make any transactions, in which case the profit would be 0.
    \begin{enumerate}
      \item[-] \textbf{Buy low... sell high}: To achieve this, init two pointers, left wanting to find the low value in the arr, and right wanting to find the high value. Init left to first index, and right to second index in array
      \item[-] Begin looping through, so long as the right pointer is less than the length of the array
      \item[-] If the right value is ever less than the left value, then you have found a new low to sell at. \textit{So assign left equal to right, and increment right by one: continue the while loop}
      \item[-] Upon each iteration check if the difference between right and left values is greater than global profit (which is init to 0). If so, update profit 
    \end{enumerate}
\end{enumerate}

\subsection{Longest Substring Without Repeating Characters}
\begin{enumerate}
  \item[] \textbf{Question:} Given a string s, find the length of the longest substring without duplicate characters.

A substring is a contiguous sequence of characters within a string.

    \begin{enumerate}
      \item[-] \textbf{Main Idea: } This is a sliding window question. The idea is that you will have two pointers start at the beginning of the string, and increment the right pointer, so long as the next character hasn't already occurred in the substring
      \item[-] More formally: get a local max-len, as well as a global max-len. Begin by incrementing the right pointer and adding the char to some tracked char array, so long if it isn't in the char array already. 
      \item[-] If it is, then we need to \textit{increment the left pointer}, and remove whatever value the left pointer is at from our tracked chars arr or hashmap. When we remove a char, be sure to decrement our local max-len.
      \item[-] Keep incrementing left pointer and removing from array until we've removed the character that the right pointer was pointing at. Once at this point, we can now continue to increment the right pointer as above. 
      \item[-] When incrementing right pointer, always update the local max, and check if it's greater than the global max
      \item[-] Once the left pointer has reached the end of the string, stop and return the global max
    \end{enumerate}
\end{enumerate}



\section{Stack}
\subsection{Valid Parentheses}
\begin{enumerate}
  \item[] \textbf{Question:}You are given a string s consisting of the following characters: '(', ')', '\{', '\}', '[' and ']'.

The input string s is valid if and only if:
 -- Every open bracket is closed by the same type of close bracket.
 -- Open brackets are closed in the correct order.
 -- Every close bracket has a corresponding open bracket of the same type.

Return true if s is a valid string, and false otherwise.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Use a Stack to push open brackets, and pop closed brackets
      \item[-] Before iterating through each char of the string, create an array of valid open brackets, and an array of valid close brackets (same positioning in each) 
      \item[-] For each char, if the char is neither in each bracket array, return false. 
      \item[-] If the char is an open bracket, push to stack 
      \item[-] If the char is an close bracket, \textit{first check if the stack is non empty} then check to see if the last value on the stack is the corresponding open bracket to the current close bracket
      \item[-] Continue looping if it is, return false if it isn't
      \item[-] After the loop completes, ensure that the stack is empty, if it is, return true

    \end{enumerate}
\end{enumerate}

\subsection{Min Stack}
\begin{enumerate}
  \item[] \textbf{Question:} Design a stack class that supports the push, pop, top, and getMin operations.

-- MinStack() initializes the stack object.
-- void push(int val) pushes the element val onto the stack.
-- void pop() removes the element on the top of the stack.
-- int top() gets the top element of the stack.
-- int getMin() retrieves the minimum element in the stack.

\textbf{Each function should run in O(1) time.}
    
    \begin{enumerate}
      \item[-] \textbf{Main idea:} This question is very easy except for returning the min in O(1) time. The idea here is to use another internal stack to keep track of all mins, as they are added.
      \item[-] We can also set up another class var called current min. This is the value that we actually return when getMin() function is called. 
      \item[-] Using internal stack to keep track of min goes as follows: if a new added value is less than the current min, then update the new current min to this value, as well as add this value to the internal min stack 
      \item[-] If we pop the value, and it is the current min, then we need to pop the value from both the regular stack, as well as the min stack, and set the new current min to the top (last) value in the min stack. If the min stack is empty, just set the current min to NONE (current min will be init as NONE).
    \end{enumerate}
\end{enumerate}


\section{Binary Search}
\subsection{Binary Search Recursive}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an array of distinct integers nums, sorted in ascending order, and an integer target.

Implement a function to search for target within nums. If it exists, then return its index, otherwise, return -1.

Your solution must run in O(logn) time.
    \begin{enumerate}
      \item[-] \textbf{Main idea:} To solve this problem recursively, you must keep track of left and right indices upon each recursive call
      \item[-] Initialize left to be index zero, and right to be last index (len(A) -1)
      \item[-] \textit{Base Case: }If left index equals right index, check if the value is in only position, if it is, return index, else return -1
      \item[-] If left doesn't equal right, find the mid index, and compare target value to value at middle index
      \item[-] If it equals the middle index, return
      \item[-] If it's greater than the middle index, recurse, left = middle index + 1
      \item[-] If it's less than the middle index, recurse, right = middle index - 1
      \item[-] \textbf{If parameters don't use left and right, you'll have to add them initially as none as defaults, then set them before recursing}

    \end{enumerate}
\end{enumerate}
\subsection{Binary Search Iterative}
\begin{enumerate}
  \item[] \textbf{Question:}  You are given an array of distinct integers nums, sorted in ascending order, and an integer target.

Implement a function to search for target within nums. If it exists, then return its index, otherwise, return -1.

Your solution must run in O(logn) time.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} To solve this problem iteratively, you must keep track of left and right indices and use a while loop
      \item[-] \textit{While loop Condition:} Loop so long as right is greater than or equal to the left index 
      \item[-] \textit{Base Case: } Within the while loop, calculate the mid index: \textbf{ mid = left + (diff between right and left / 2)}
      \item[-] If the target equals the mid index, return mid index
      \item[-] If left target is greater, then left becomes mid index +1
      \item[-] If it's less than the middle index right = middle index - 1
      \item[-] return -1 if not found (outside while loop)


    \end{enumerate}
\end{enumerate}



\subsection{Search 2D Matrix}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an m x n 2-D integer array matrix and an integer target.

  Each row in matrix is sorted in non-decreasing order.
  The first integer of every row is greater than the last integer of the previous row.
  Return true if target exists within matrix or false otherwise.

Can you write a solution that runs in O(log(m * n)) time?
    \begin{enumerate}
      \item[-] \textbf{Main idea:} Need to preform binary search \textit{twice}.
      \item[-] First binary search is done on the first column, which approximates where the actual value is 
      \item[-] To preform this first search, set up \textit{iterative} binary search as usual
      \item[-] \textbf{Edge Case:} When checking if the value is greater than the first in the row, must also check if the value is less than or EQUAL TO the last value in that row. This means that the value is \textit{in} that row.
      \item[-] If this condition is true, then you have found the row, and you can break from the first binary search loop. Store this row as the second array you will search over 
      \item[-] Now preform Binary Search a second time on this row, and return true or false depending on if the value was found or not

    \end{enumerate}
\end{enumerate}


\subsection{Koko eats Bananas}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an integer array piles where piles[i] is the number of bananas in the ith pile. You are also given an integer h, which represents the number of hours you have to eat all the bananas.

You may decide your bananas-per-hour eating rate of k. Each hour, you may choose a pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, you may finish eating the pile but you can not eat from another pile in the same hour.

Return the minimum integer k such that you can eat all the bananas within h hours.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} The hardest part of this question is knowing what to preform a binary search on, as we need to find the minimum integer k such that all bananas can be eaten within h hours. In this case, the max that k can be is the largest pile.
      \item[-] \textit{Simplified Solution:} Preform binary search from k = 1 to max pile amount in banana piles: In other words, preform binary search on [1, max(piles)].
      \item[-] In this case, we start at the half way pile. For this k value, check to see if all the bananas can be completed with this rate.
      \item[-] If it cannot, this k value is too small, and we need to retry with a new larger k. So preform binary search on the upper half. 
      \item[-] If all the values can be completed in this time, this is a valid k, but it isn't necessarily the \textit{smallest} k value. So we need to preform binary search again anyway on the left side of the array. 
      \item[-] If the smaller value doesn't work, then return the current min. If it does, repeat until the current min is the smallest working one.

    \end{enumerate}
\end{enumerate}




\section{Linked Lists}

\subsection{Reverse Linked List}
\begin{enumerate}
  \item[] \textbf{Question:} Given the beginning of a singly linked list head, reverse the list, and return the new beginning of the list.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Set up a previous and current pointer node that will be used to reassign next pointer values
      \item[-] First check to see if the head node exists, if so, init prev to None, and current to the head 
      \item[-] While loop condition is while current exists: 
      \item[-] Create a temp value that stores currents next node value
      \item[-] Set current.next equal to prev 
      \item[-] Set prev equal to current 
      \item[-] Set current equal to temp
      \item[-] Once this loop has finished, the current value will be None, and we need to return the new head, which is the last node that came before None
      \item[-] So we return prev


    \end{enumerate}
\end{enumerate}

\subsection{Cycle Detection Linked List}
\begin{enumerate}
  \item[] \textbf{Question:} Given the beginning of a linked list head, return true if there is a cycle in the linked list. Otherwise, return false.

There is a cycle in a linked list if at least one node in the list can be visited again by following the next pointer.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Set up a two pointers, one fast pointer and one slow pointer
      \item[-] The slow pointer will increment one each upon each iteration, the fast pointer will increment by two.
      \item[-] The idea is that the gap between the fast and slow pointer will gradually grow smaller and smaller until they point to the same node. This can only happen if there is a loop in the linked list
      \item[-] Set up both pointers to begin at the head node, if the head exists
      \item[-] Looping condition: While first pointer exists: first = first.next
      \item[-] Check if second.next and second.next.next exists, if so, second = second.next.next
      \item[-] Check if first = second. \textit{Note:} Must specifically check that first equals second and not their values. Checking if the node struct stored in memory is the same struct, not just the values!
    \end{enumerate}
\end{enumerate}

\subsection{Merge Two Sorted Lists}
\begin{enumerate}
  \item[] \textbf{Question:} You are given the heads of two sorted linked lists list1 and list2.

Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.

Return the head of the merged linked list.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Create a new head node that you will add two each list to, depending on which list has the smaller node when comparing the two
      \item[-] Set up a current node that will be assigned to the new head node
      \item[-] While looping condition: If list1 and list2, continue looping and comparing 
      \item[-] At the beginning of each loop, create a new node, and assign current at list1 or list2 to the new node depending on which one is smaller (increment list1 = list1.next or list2 = list2.next, depending on which was smaller)
      \item[-] Set the current.next to new node, and then increment current: current = current.next 
      \item[-] After while loop is finished, check if list1 or list2 still has any nodes, if either does, assign the remaining to the current.next
      \item[-] Return new-head.next (because new head is just a dummy node, and doesn't have any value)



    \end{enumerate}
\end{enumerate}


\section{Trees}

\subsection{Invert Binary Tree}
\begin{enumerate}
  \item[] \textbf{Question:} You are given the root of a binary tree root. Invert the binary tree and return its root. 

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Preform a DFS on the tree, before exploring left and right children, swap the left and right 
      \item[-] In explore function, first check if the current node is None, this is the base case: If it is, simply return 
      \item[-] If not None, create a temp node, and swap the left and right children. Then explore left node, and explore right node
      \item[-] Explore function can be written as a part of the Solution Class
      \item[-] In main function, call explore on root, then return root


    \end{enumerate}
\end{enumerate}


\subsection{Max Depth of Binary Tree}
\begin{enumerate}
  \item[] \textbf{Question:} Given the root of a binary tree, return its depth.

The depth of a binary tree is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Preform a DFS on the tree, at each sub-problem, we want to pass up the max of the left and right at the current node
      \item[-] In explore function, first check if the current node is None, this is the base case: If it is, simply return 
      \item[-] If not None, recurse on the left and right parts of the tree and store the depths, then return upward the max(left, right)
      \item[-] Explore function can be written as a part of the Solution Class
      \item[-] In main function, return the call to explore


    \end{enumerate}
\end{enumerate}

\subsection{Max Diameter of Binary Tree}
\begin{enumerate}
  \item[] \textbf{Question:} The diameter of a binary tree is defined as the length of the longest path between any two nodes within the tree. The path does not necessarily have to pass through the root.

The length of a path between two nodes in a binary tree is the number of edges between the nodes.

Given the root of a binary tree root, return the diameter of the tree.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Create a attribute of the Solution class (called max diameter) then preform a DFS on the tree
      \item[-] The max diameter at each level is the longest number of edges spanning the left and right branches \textit{added together}.
      \item[-] The base case in this sense is if the current is NONE, it it is, RETURN -1, as there are no edges between the NONE node and the parent Node. 
      \item[-] At each sub-problem, recurse on the left and right sides (adding 1 to the return), and check if right added to left is greater than the member class var of max diameter. 
      \item[-] If it is, set max diameter. 
      \item[-] We want to pass up the longest span at any given node, which is the max between the left and right span
      \item[-] Call explore function from max diameter, and return the int value that explore returns. 

    \end{enumerate}
\end{enumerate}


\subsection{Balanced Binary Tree}
\begin{enumerate}
  \item[] \textbf{Question:} The depth of a binary tree is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} This question is a bit trickier, as you need to return a tuple, and not just a depth (like edge depth or node depth)
      \item[-] To begin preform a DFS on the tree. Start be defining the base case. If the node is NONE, return (0, True), as a None node is balanced. Because we are defining balance in terms of node height, and not edge height, base case starts at 0 and not -1.
      \item[-] Next, recurse on the left and right sub trees, and add one to the depth part of the tuple and store the True or False vale. 
      \item[-] Check if the distance between left and right is equal to 1 or 0, if it is, set a current balanced value equal to True. 
      \item[-] If this current balanced is True, and so are the left and right return T/F values are true, then return True upwards to the next subproblem. 
      \item[-] In terms of return depth upwards, we want to return the max depth between the left and right sub nodes.
      \item[-] So, return (max(left, right), (is-bal and left-bal and right-bal)) upwards
      \item[-] In main function, return the True or false value from the tuple as the answer


    \end{enumerate}
\end{enumerate}



\subsection{Same Binary Tree}
\begin{enumerate}
  \item[] \textbf{Question:} Given the roots of two binary trees p and q, return true if the trees are equivalent, otherwise return false.

Two binary trees are considered equivalent if they share the exact same structure and the nodes have the same values.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Use DFS to search through each tree, checking nodes along the way. If DFS is preformed in the same order for both trees, then they are the same
      \item[-] Two ways of solving this question: First is less buggy, but also less efficient. Idea is to create one explore call, and a visited array, and add nodes to the array upon being visited. Call explore twice, with two separate visited arrays, one for each tree
      \item[-] Check the arrays, if they are the same, return true, else return False. 
      \item[-] \textit{NOTE}: Doing it this way means you need to express the NULL Node in the array: In the base case, make sure to add None to the array, when you hit a None node.
      \item[-] \textbf{BETTER WAY:} A better way is to modify the explore function directly and have it accept two nodes.
      \item[-] Base case in this example becomes if \textit{both} nodes are None, return True upwards. If one node exists, and the other doesn't. Return False. 
      \item[-] Recurse on the left and right subtrees, comparing nodes as you go.

    \end{enumerate}
\end{enumerate}

\subsection{Subtree of Another Tree}
\begin{enumerate}
  \item[] \textbf{Question:} Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.

A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.


    \begin{enumerate}
      \item[-] \textbf{Main idea:} Use DFS to search through the main root tree. At each node, check if the current node val equals the target node val. If they do, then we can begin an is same tree check with this node as our new root. 
      \item[-] Checking if a tree is the same can be done in the two ways described in the previous question. We can use a DFS approach, and explore / check as we go, or create arrays that track the order in which the tree was traversed, and compare the arrays
      \item[-] \textit{SERIALIZE THE TWO TREES}: After banging my head against the wall, the best move it to serialize the lists.
      \item[-] Once this exploration and checking has been done, if the result is true, we must set a global variable to True, if it's not, we can  \textit{keep exploring} the main rooted tree. 
      \item[-] If the main rooted tree gets completely traversed, return false
      \item[-] Can create the root serizization in each stack frame: examine code for best practice in using serialization

    \end{enumerate}
\end{enumerate}

\subsection{Binary Tree Level Order Traversal}
\begin{enumerate}
  \item[] \textbf{Question:} Given a binary tree root, return the level order traversal of it as a nested list, where each sublist contains the values of nodes at a particular level in the tree, from left to right. 

    \begin{enumerate}
      \item[-] \textbf{Main idea:} This question boils down to preforming breadth first search and assigning nodes a level number when preforming the traversal. 
      \item[-] To begin, set up a queue, because queues are used to preform BFS. Also set up a level number and assign level=0. 
      \item[-] Start by putting the root and level=0 in the queue as a tuple. Now preform BFS on the queue. 
      \item[-] Inside the explore function, if the current node has a left and right, add them to the queue as you normally would, but as a tuple with level+=1. More specifically add (current.left, level+=1) and (current.right, level+=1) to the queue. 
      \item[-] This will properly assign each node to a level. When returning back from BFS, simply group together all values that have the same level into an array. 

    \end{enumerate}
\end{enumerate}





\section{Heap and Priority Queue}

\subsection{Kth Largest Element in a Stream}
\begin{enumerate}
  \item[] \textbf{Question:} 
    Design a class to find the kth largest integer in a stream of values, including duplicates. E.g. the 2nd largest from [1, 2, 3, 3] is 3. The stream is not necessarily sorted.

Implement the following methods:

 - constructor(int k, int[] nums) Initializes the object given an integer k and the stream of integers nums.\\
 - int add(int val) Adds the integer val to the stream and returns the kth largest integer in the stream.



    \begin{enumerate}
      \item[-] \textbf{Main idea:} Use a heap! By default, python has a built in heap library called heapq that uses min heaps
      \item[-] In the constructor set the value k to self.k 
      \item[-] Next, heapify the array, this is basically a free operation, as it takes liner time : O(n). \textit{NOTE:} Heapify happens in place (pass by reference), this means that we do not assign the array to a new variable. 
      \item[-] Next set the heapifyed array to another attribute variable (say streams).
      \item[-] In the addition function, first heappush() the value into the array. 
      \item[-] \textbf{heappush() time complexity: } Heappush adds the new values to the last value of the tree, the bubbles up. Bubbling up involves swapping nodes upward towards the root. This swapping can occur a max number of times thats equal to the height of the tree. So worst case is O(log(n)), time.
      \item[-] \textbf{heappop() time complexity: } Heappop is simular to heappush, as it swaps nodes. Only the root is swapped with a leaf node, the leaf node is removed and returned, and sink down swapping function is called on the root. This again can happen in O(log(n)) time. 
      \item[-] In our add function, after we've added the node, we can now heap pop so long as the length of the stream is greater than our kth value. In other words, keep popping until you've popped k times: return the kth element. Time complexity is O(klog(n))
    \end{enumerate}
\end{enumerate}


\subsection{Last Stone Weight}
\begin{enumerate}
  \item[] \textbf{Question:} 
    You are given an array of integers stones where stones[i] represents the weight of the ith stone.

We want to run a simulation on the stones as follows:

At each step we choose the two heaviest stones, with weight x and y and smash them together  
  \begin{enumerate}
    \item[-] If x == y, both stones are destroyed
    \item[-]  If x < y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.
    \item[-] Continue the simulation until there is no more than one stone remaining. 
\end{enumerate}
Return the weight of the last remaining stone or return 0 if none remain.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Use a heap! This is a max heap problem, so the hardest part about the solution is ensuring we're translating the question correctly while using our min heap. To begin, we can multiply every value by -1 in the array, then call heapify. 
      \item[-] In the simulation, we choose the two heaviest stones, which means the two most negative stones. So heappop twice, and set x and y equal to the return values. Loop and grab the two largest values so long as the length of the heap is greater than 1
      \item[-] Now check to see if both of the values are the same, if they are, continue to the next iteration (continue inside while loop)
      \item[-] If x < y, then we must be careful in translating this to logic in the question, this condition will only happen if x is actually greater than y due to the values being negative. If this is the case, then we need to add y back in with weight y-x. In this case, we will add y back in with weight x - y. To see this math work out, I suggest writing out a couple of values to see how the negative works.
      \item[-] Once the looping expression evals to false, check to see if there are 1 or None values left in the heap
      \item[-] If there are none, then return 0, else, return -1 * heap[0] - > remember to turn the negative back to positive!
    \end{enumerate}
\end{enumerate}


\subsection{K Closest Points to Origin}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an 2-D array points where points[i] = [xi, yi] represents the coordinates of a point on an X-Y axis plane. You are also given an integer k.

Return the k closest points to the origin (0, 0).

The distance between two points is defined as the Euclidean distance $(sqrt((x1 - x2)^2 + (y1 - y2)^2))$.

You may return the answer in any order.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Use a heap to store the distance values! Start by looping through all the points, and calculating the distances of each point. 
      \item[-] Once you've calculated the distance, store that distance in an array that you'll heapify
      \item[-] Also store the distance as the key in a hashmap: the values will be \textit{an array of all the (x,y) coordinates that form this distance}
      \item[-] Once you have heapifyed the distance array, begin heappopping and looking up a x,y values from the array of possible values.
      \item[-] Add each (x,y) value as an array to an answer array. Do this k times, then return the answer array
    \end{enumerate}
\end{enumerate}


\section{Graphs}

\subsection{Number of Islands}
\begin{enumerate}
  \item[] \textbf{Question:}Given a 2D grid grid where '1' represents land and '0' represents water, count and return the number of islands.

An island is formed by connecting adjacent lands horizontally or vertically and is surrounded by water. You may assume water is surrounding the grid (i.e., all the edges are water). 

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Preform a DFS on the graph using a visited nodes list. Explore all neighbor nodes of a starting node, so long as the neighbor has not been visited. 
      \item[-] We will wrap the DFS call in a for loop that loops through every node. Every time the explore call returns, we will += our island counter by the return call of explore (which will return 1 or 0). This is the value that we will eventually return.
      \item[-] Inside our explore function, we must first check to see if the node had a value 1 or 0, if its 0, simply 0
      \item[-] If the value is 1, then we can explore all of the nodes neighbors. 
      \item[-] We can fist built our another function that returns all the neighbors of the given node. We can then loop through this list, for every non-visited neighbor.
      \item[-] After we have finished the recursive calling, we can return 1 to the parent wrapper function. 
      \item[-] Now having finished exploring the graph, we can return the island counter. 
      \item[-] \textbf{Note:} I used a list of tuples (x,y) to store visited nodes, but there's probably a better way to do this. 
    \end{enumerate}
\end{enumerate}


\subsection{Max Area of Islands}
\begin{enumerate}
  \item[] \textbf{Question:} You are given a matrix grid where grid[i] is either a 0 (representing water) or 1 (representing land).

An island is defined as a group of 1's connected horizontally or vertically. You may assume all four edges of the grid are surrounded by water.

The area of an island is defined as the number of cells within the island.

Return the maximum area of an island in grid. If no island exists, return 0.


    \begin{enumerate}
      \item[-] \textbf{Main idea:} Preform a DFS on the graph using a visited nodes list. Explore all neighbor nodes of a starting node, so long as the neighbor has not been visited. 
      \item[-] We will wrap the DFS call in a for loop that loops through every node. Inside the explore call, we need to have an internal counter that adds to the area as we traverse. We then return that area back to the parent function, and test to see if its greater than whatever our current max area is. 
      \item[-] As for the other inland question, we can fist built another function that returns all the neighbors of the given node. We can then loop through this list, for every non-visited neighbor.
      \item[-] Once our main parent for loop has terminated, we should have counted all the island's areas, and found the largest.
      \item[-] \textbf{Note:} Recursively internally counting can get tricky, make sure you consider what you're passing up to the parent. One way of doing this is to have a local area number set to 1, then return that area upward when you do the recursive call. 
    \end{enumerate}
\end{enumerate}

\section{Advanced Graphs}

\subsection{Network Delay Time}
\begin{enumerate}
  \item[] \textbf{Question:} You are given a network of n directed nodes, labeled from 1 to n. You are also given times, a list of directed edges where times[i] = (ui, vi, ti).

\begin{enumerate}
  \item[-] ui is the source node (an integer from 1 to n)
  \item[-] vi is the target node (an integer from 1 to n)
  \item[-] ti is the time it takes for a signal to travel from the source to the target node (an integer greater than or equal to 0).

\end{enumerate}
You are also given an integer k, representing the node that we will send a signal from.

Return the minimum time it takes for all of the n nodes to receive the signal. If it is impossible for all the nodes to receive the signal, return -1 instead.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} This is a classic DIJKSTRAS ALGO approach. I'm going to walk through the best steps in order to implement DIJKSTRAS in python, because although you knew how to do this problem, implementing DIJKSTRAS correctly was actually really buggy and hard.
      \item[-] To begin, change whatever internal data structure they give you into an adjacency list. 
      \item[-] The adjacency list is a dictionary, where the key is a node, and the value is a tuple with the neighbor node (v) and the weight between (u,v). \textbf{NOTE:} Not every node will be in the adjacency list! This is as expected
      \item[-] Once you have created the adjacency list, we now need to create the distances dictionary that will keep track of the currently running distances to each node. To begin, set the start node k to distance 0. (Distance from k to itself is just 0). Next, for all the remaining nodes, set the distance to INF. (Will use math.inf, which requires importing math). 
      \item[-] Next, set up the min-heap that you will \textit{heappush and heappop from}. Put the starting tupple (0, k) in the min heap
      \item[-] Now start the main looping. While the length of the min heap isn't 0, pop the tuple with the smallest distance. Because this is a heap, just heappop.
      \item[-] Now that you have the current smallest, check to see if the current stored distance to this node is smaller than the current distance popped from the heap. If it is smaller, then we can continue in the loop, as there is already a shorter distance found to this node. 
      \item[-] If it's not smaller, then for every neighbor in the adjacency list of this node, we must preform the following check: distances[v] > curr-dist + w
      \item[-] if this is true, then we must update distance[v] to curr-dist + w, and then heappush this neighbor and weight into the min-heap
      \item[-] After the while loop has finished, and all nodes have been explored, we can check if any nodes were unreachable, in this case, if any nodes in the distances dictionary are math.inf, then return -1
      \item[-] If all distances are in the dictionary, then we must return the max of all the distances in the dictionary, this equal the min over all nodes that needed to be communicated to. This problem was kinda annoying to solve because I had to implement DIJKSTRAS for the first time but moving forward hopefully it's not too bad
    \end{enumerate}
\end{enumerate}



\section{One-Dimensional Dynamic Programming}

\subsection{Climbing Stairs}
\begin{enumerate}
  \item[] \textbf{Question:}You are given an integer n representing the number of steps to reach the top of a staircase. You can climb with either 1 or 2 steps at a time.

Return the number of distinct ways to climb to the top of the staircase.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} We can use \textbf{Memoization} to keep track of sub solutions to each part of the problem. 
      \item[-] \textbf{Subproblem:} At each step, the number of distinct ways that can be reached is the sum of the number of distinct ways that can be reached at steps n-1 and n-2. memo[n-1] + memo[n-2].
      \item[-] We can set our current memo value, to the sum of the precious two memo values. 
      \item[-] To begin this problem, (or any DP problem), always start by populating the memo with the base cases of the problem.
      \item[-] In this case, we populate our memo with   memo = {1:1, 2:2} 
      \item[-] At the beginning of our recursion, we will check to see if the current value step is in the memo, if it is, then we return that memo value. 
      \item[-] If not, we add a new entry to our memo that equals our sub problem: memo[n] = memo[n-1] + memo[n-2]. To do this, we first must check to make sure that memo[n-1] and memo[n-2] exist. If we're doing the top down approach, they won't, so we make a recursive call:  memo[n] = self.memoClimb(n-1, memo) + self.memoClimb(n-2, memo). 
      \item[-] We then return the memo[n] upward 
      \item[-] \textbf{Note:} This problem can also be done iteratively, and honestly probably is easier to do that way, I put both my solutions in the python file.
    \end{enumerate}
\end{enumerate}


\subsection{Min Cost Climbing Stairs}
\begin{enumerate}
  \item[] \textbf{Question:}
      You are given an array of integers cost where cost[i] is the cost of taking a step from the ith floor of a staircase. After paying the cost, you can step to either the (i + 1)th floor or the (i + 2)th floor.

      You may choose to start at the index 0 or the index 1 floor.

      Return the minimum cost to reach the top of the staircase, i.e. just past the last index in cost.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} We can use \textbf{Memoization} to keep track of sub solutions to each part of the problem. 
      \item[-] \textbf{Subproblem:} At each step, the minimal cost would be the cost to get to that current step, plus the min at steps n-1, n-2. : memo[step] = currentCost + min(self.memoStairs(step-1, cost, memo), self.memoStairs(step-2,cost, memo))
      \item[-] To begin this problem, (or any DP problem), always start by populating the memo with the base cases of the problem.
      \item[-] In this case, we populate our memo with the costs associated at steps 1 and 2
      \item[-] At the beginning of our recursion, we will check to see if the current value step is in the memo, if it is, then we return that memo value. 
      \item[-] If not, we add a new entry to our memo that equals our sub problem. 
      \item[-] Because we need to get to the last stair, the stair that doesn't have a value, we need to create a current cost variable that tracks the current values current cost. If the last stair is met, then the current cost will just equal 0. 
      \item[-] After all of the recursion has been done, we will return memo[step]
    \end{enumerate}
\end{enumerate}

\section{Two-Dimensional Dynamic Programming}
\subsection{Unique Paths}
\begin{enumerate}
  \item[] \textbf{Question:}
    There is an m x n grid where you are allowed to move either down or to the right at any point in time.

Given the two integers m and n, return the number of possible unique paths that can be taken from the top-left corner of the grid (grid[0][0]) to the bottom-right corner (grid[m - 1][n - 1]).

You may assume the output will fit in a 32-bit integer.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} This question is not bad at all. Consider the following: At any point on the grid, you only have two options, move down, or move to the right. The total number of ways to reach the current square is the sum between the number of ways you could move at the square down, plus the number of ways from the square at the right.
      \item[-] At each square, add the numbers of ways at grid[i+1][j] + grid[i][j+1]. This gives you the total number of ways at grid[i][j].
      \item[-] Say you are just to the left of the final state, in this case, you cannot add whats below, because it doesn't exist. To solve this, expand the rows and columns by one, and fill in these as 0. So now when you add from this "out of bounds row", you simply add zero. 
      \item[-] Start looping the last row, upwards toward the starting position. Make sure to mark the final node grid[m-1][n-1] equal to 1!
      \item[-] After you've looped from the bottom row upward to the top row, making sure to add the right and bottom cells as you go, the final total amount of ways is the numbers of ways at the starting element: grid[0][0]: this is the solution.
    \end{enumerate}
\end{enumerate}


\section{Backtracking}
\subsection{Subsets ** Need to come back and study this question}

\section{Greedy}
\subsection{Jump Game}
\begin{enumerate}
  \item[] \textbf{Question:}
  You are given an integer array nums where each element nums[i] indicates your maximum jump length at that position.

  Return true if you can reach the last index starting from index 0, or false otherwise.
    \begin{enumerate}
      \item[-] \textbf{Main idea:} This question is greedy: the trick is to \textbf{start at the end of the array and work toward the beginning of the array}. If you work backwards, and you know that the previous element can reach the next, then you set the previous to the new end. Keep repeating this until your "end point" becomes the beginning of the array. If this is the case, then return true
      \item[-] You can use two pointers, left and right. Start right pointer at the end of the array, and the left pointer at one less than right.
      \item[-] Keep and ongoing variable that tracks the distance between the left and right nodes. (This value starts at 1)
      \item[-] If the value at the left pointer is ever greater than the distance between the current left and right, then set the right to the current left, and reset the distance between back to 0. 
      \item[-] If not, then decrement the left variable, and add to the distance between.
      \item[-] If left index becomes zero, and the current right index doesn't also equal zero, then the last element was not reachable from the first element: if it is zero, then return true
    \end{enumerate}
\end{enumerate}

\subsection{Gas Station}
\begin{enumerate}
  \item[] \textbf{Question:}

   There are n gas stations along a circular route. You are given two integer arrays gas and cost where:
   \begin{enumerate}
     \item[-] gas[i] is the amount of gas at the ith station.
     \item[-] cost[i] is the amount of gas needed to travel from the ith station to the (i + 1)th station. (The last station is connected to the first station)

\end{enumerate}
You have a car that can store an unlimited amount of gas, but you begin the journey with an empty tank at one of the gas stations.

Return the starting gas station's index such that you can travel around the circuit once in the clockwise direction. If it's impossible, then return -1.

It's guaranteed that at most one solution exists.


    \begin{enumerate}
      \item[-] \textbf{Main idea:} Take the differences between the gas station positive amount, and the cost. Begin a tank counter variable that keeps track of the amount of gas in the tank. For each station, take the difference between the fill up amount, and the cost, and add it to the ongoing tank counter amount. Store this index that you started at as the first "potential solution index"
      \item[-] If the tank counter amount is ever negative, reset the "potential solution index" to be the next index, and also set the tank amount back to zero
      \item[-] Keep looping through the gas station array repeating this process: at the end of the loop, the index where the tank counter never went negative is the solution index.
      \item[-] \textit{Another thing to check first is if the summation of the gas array is greater than or equal to the summation of the cost array: if not, then return -1 as the solution is not possible}
    \end{enumerate}
\end{enumerate}







\end{document}

