\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{enumitem}  

\title{Leetcode Notes and Practice}
\author{Sebastian Pucher}

\begin{document}
\maketitle                             


\tableofcontents

\newpage

\section{Hashing}
\subsection{Valid Anagram}
\begin{enumerate}
  \item[] \textbf{Question:} Given two strings s and t, return true if the two strings are anagrams of each other, otherwise return false
    \begin{enumerate}
      \item[-] Create two separate dictionaries
      \item[-] Loop through one of the input strings, add key letter or letter freq.
      \item[-] If dict are the same, return true
    \end{enumerate}
\end{enumerate}

\subsection{Twosum}
\begin{enumerate}
  \item[] \textbf{Question:} Given an array of integers nums and an integer target, return the indices i and j such that nums[i] + nums[j] == target and i != j
    \begin{enumerate}
      \item[-] Use a hashmap to store the index of each number in the array as the \textit{value}
      \item[-] On each iteration, check first to see if the difference between the target val and the current num is already stored in the hashmap
      \item[-] If it is, then return the value at that key (the index), as well as the current index i
      \item[-] If it's not, then add the current number and index to the hashmap 
      \item[-] \textbf{Key Idea: } Always check the existence between the target and the current number as a key in the hashmap first!
    \end{enumerate}
\end{enumerate}

\section{Two Pointers}
\subsection{Valid Palindrome}
\begin{enumerate}
  \item[] \textbf{Question:} Given a string s, return true if it is a palindrome, otherwise return false.

A palindrome is a string that reads the same forward and backward. It is also case-insensitive and ignores all non-alphanumeric characters.
    \begin{enumerate}
      \item[-] First change the string to all lowercase with .lower() function, this ensures case sensitive args are taken care of
      \item[-] Init left and right pointers to first and last characters
      \item[-] Do a check using \textbf{.isalnum()}. If it is \textit{not} alpha numeric, then increment or decrement the pointer and \textit{continue} through the loop
      \item[-] While left is less than or equal two right, compare the letters, if not the same, return false
      \item[-] increment / decrement left and right at bottom of loop
    \end{enumerate}
\end{enumerate}

\section{Sliding Window}
\subsection{Best Time to Buy and Sell Stocks}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an integer array prices where prices[i] is the price of NeetCoin on the ith day.

You may choose a single day to buy one NeetCoin and choose a different day in the future to sell it.

Return the maximum profit you can achieve. You may choose to not make any transactions, in which case the profit would be 0.
    \begin{enumerate}
      \item[-] \textbf{Buy low... sell high}: To achieve this, init two pointers, left wanting to find the low value in the arr, and right wanting to find the high value. Init left to first index, and right to second index in array
      \item[-] Begin looping through, so long as the right pointer is less than the length of the array
      \item[-] If the right value is ever less than the left value, then you have found a new low to sell at. \textit{So assign left equal to right, and increment right by one: continue the while loop}
      \item[-] Upon each iteration check if the difference between right and left values is greater than global profit (which is init to 0). If so, update profit 
    \end{enumerate}
\end{enumerate}

\section{Stack}
\subsection{Valid Parentheses}
\begin{enumerate}
  \item[] \textbf{Question:}You are given a string s consisting of the following characters: '(', ')', '\{', '\}', '[' and ']'.

The input string s is valid if and only if:
 -- Every open bracket is closed by the same type of close bracket.
 -- Open brackets are closed in the correct order.
 -- Every close bracket has a corresponding open bracket of the same type.

Return true if s is a valid string, and false otherwise.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Use a Stack to push open brackets, and pop closed brackets
      \item[-] Before iterating through each char of the string, create an array of valid open brackets, and an array of valid close brackets (same positioning in each) 
      \item[-] For each char, if the char is neither in each bracket array, return false. 
      \item[-] If the char is an open bracket, push to stack 
      \item[-] If the char is an close bracket, \textit{first check if the stack is non empty} then check to see if the last value on the stack is the corresponding open bracket to the current close bracket
      \item[-] Return continue looping if it is, return false if it isn't
      \item[-] After the loop completes, ensure that the stack is empty, if it is, return true
        

    \end{enumerate}
\end{enumerate}



\end{document}

