\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{enumitem}  

\title{Leetcode Notes and Practice}
\author{Sebastian Pucher}

\begin{document}
\maketitle                             


\tableofcontents

\newpage

\section{Hashing}
\subsection{Valid Anagram}
\begin{enumerate}
  \item[] \textbf{Question:} Given two strings s and t, return true if the two strings are anagrams of each other, otherwise return false
    \begin{enumerate}
      \item[-] Create two separate dictionaries
      \item[-] Loop through one of the input strings, add key letter or letter freq.
      \item[-] If dict are the same, return true
    \end{enumerate}
\end{enumerate}

\subsection{Twosum}
\begin{enumerate}
  \item[] \textbf{Question:} Given an array of integers nums and an integer target, return the indices i and j such that nums[i] + nums[j] == target and i != j
    \begin{enumerate}
      \item[-] Use a hashmap to store the index of each number in the array as the \textit{value}
      \item[-] On each iteration, check first to see if the difference between the target val and the current num is already stored in the hashmap
      \item[-] If it is, then return the value at that key (the index), as well as the current index i
      \item[-] If it's not, then add the current number and index to the hashmap 
      \item[-] \textbf{Key Idea: } Always check the existence between the target and the current number as a key in the hashmap first!
    \end{enumerate}
\end{enumerate}

\section{Two Pointers}
\subsection{Valid Palindrome}
\begin{enumerate}
  \item[] \textbf{Question:} Given a string s, return true if it is a palindrome, otherwise return false.

A palindrome is a string that reads the same forward and backward. It is also case-insensitive and ignores all non-alphanumeric characters.
    \begin{enumerate}
      \item[-] First change the string to all lowercase with .lower() function, this ensures case sensitive args are taken care of
      \item[-] Init left and right pointers to first and last characters
      \item[-] Do a check using \textbf{.isalnum()}. If it is \textit{not} alpha numeric, then increment or decrement the pointer and \textit{continue} through the loop
      \item[-] While left is less than or equal two right, compare the letters, if not the same, return false
      \item[-] increment / decrement left and right at bottom of loop
    \end{enumerate}
\end{enumerate}

\section{Sliding Window}
\subsection{Best Time to Buy and Sell Stocks}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an integer array prices where prices[i] is the price of NeetCoin on the ith day.

You may choose a single day to buy one NeetCoin and choose a different day in the future to sell it.

Return the maximum profit you can achieve. You may choose to not make any transactions, in which case the profit would be 0.
    \begin{enumerate}
      \item[-] \textbf{Buy low... sell high}: To achieve this, init two pointers, left wanting to find the low value in the arr, and right wanting to find the high value. Init left to first index, and right to second index in array
      \item[-] Begin looping through, so long as the right pointer is less than the length of the array
      \item[-] If the right value is ever less than the left value, then you have found a new low to sell at. \textit{So assign left equal to right, and increment right by one: continue the while loop}
      \item[-] Upon each iteration check if the difference between right and left values is greater than global profit (which is init to 0). If so, update profit 
    \end{enumerate}
\end{enumerate}

\section{Stack}
\subsection{Valid Parentheses}
\begin{enumerate}
  \item[] \textbf{Question:}You are given a string s consisting of the following characters: '(', ')', '\{', '\}', '[' and ']'.

The input string s is valid if and only if:
 -- Every open bracket is closed by the same type of close bracket.
 -- Open brackets are closed in the correct order.
 -- Every close bracket has a corresponding open bracket of the same type.

Return true if s is a valid string, and false otherwise.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Use a Stack to push open brackets, and pop closed brackets
      \item[-] Before iterating through each char of the string, create an array of valid open brackets, and an array of valid close brackets (same positioning in each) 
      \item[-] For each char, if the char is neither in each bracket array, return false. 
      \item[-] If the char is an open bracket, push to stack 
      \item[-] If the char is an close bracket, \textit{first check if the stack is non empty} then check to see if the last value on the stack is the corresponding open bracket to the current close bracket
      \item[-] Continue looping if it is, return false if it isn't
      \item[-] After the loop completes, ensure that the stack is empty, if it is, return true
        

    \end{enumerate}
\end{enumerate}

\section{Binary Search}
\subsection{Binary Search Recursive}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an array of distinct integers nums, sorted in ascending order, and an integer target.

Implement a function to search for target within nums. If it exists, then return its index, otherwise, return -1.

Your solution must run in O(logn) time.
    \begin{enumerate}
      \item[-] \textbf{Main idea:} To solve this problem recursively, you must keep track of left and right indices upon each recursive call
      \item[-] Initialize left to be index zero, and right to be last index (len(A) -1)
      \item[-] \textit{Base Case: }If left index equals right index, check if the value is in only position, if it is, return index, else return -1
      \item[-] If left doesn't equal right, find the mid index, and compare target value to value at middle index
      \item[-] If it equals the middle index, return
      \item[-] If it's greater than the middle index, recurse, left = middle index + 1
      \item[-] If it's less than the middle index, recurse, right = middle index - 1
      \item[-] \textbf{If parameters don't use left and right, you'll have to add them initially as none as defaults, then set them before recursing}

    \end{enumerate}
\end{enumerate}
\subsection{Binary Search Iterative}
\begin{enumerate}
  \item[] \textbf{Question:}  You are given an array of distinct integers nums, sorted in ascending order, and an integer target.

Implement a function to search for target within nums. If it exists, then return its index, otherwise, return -1.

Your solution must run in O(logn) time.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} To solve this problem iteratively, you must keep track of left and right indices and use a while loop
      \item[-] \textit{While loop Condition:} Loop so long as right is greater than or equal to the left index 
      \item[-] \textit{Base Case: } Within the while loop, calculate the mid index: \textbf{ mid = left + (diff between right and left / 2)}
      \item[-] If the target equals the mid index, return mid index
      \item[-] If left target is greater, then left becomes mid index +1
      \item[-] If it's less than the middle index right = middle index - 1
      \item[-] return -1 if not found (outside while loop)


    \end{enumerate}
\end{enumerate}
\subsection{Search 2D Matrix}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an m x n 2-D integer array matrix and an integer target.

  Each row in matrix is sorted in non-decreasing order.
  The first integer of every row is greater than the last integer of the previous row.
  Return true if target exists within matrix or false otherwise.

Can you write a solution that runs in O(log(m * n)) time?
    \begin{enumerate}
      \item[-] \textbf{Main idea:} Need to preform binary search \textit{twice}.
      \item[-] First binary search is done on the first column, which approximates where the actual value is 
      \item[-] To preform this first search, set up \textit{iterative} binary search as usual
      \item[-] \textbf{Edge Case:} When checking if the value is greater than the first in the row, must also check if the value is less than or EQUAL TO the last value in that row. This means that the value is \textit{in} that row.
      \item[-] If this condition is true, then you have found the row, and you can break from the first binary search loop. Store this row as the second array you will search over 
      \item[-] Now preform Binary Search a second time on this row, and return true or false depending on if the value was found or not

    \end{enumerate}
\end{enumerate}

\section{Linked Lists}

\subsection{Reverse Linked List}
\begin{enumerate}
  \item[] \textbf{Question:} Given the beginning of a singly linked list head, reverse the list, and return the new beginning of the list.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Set up a previous and current pointer node that will be used to reassign next pointer values
      \item[-] First check to see if the head node exists, if so, init prev to None, and current to the head 
      \item[-] While loop condition is while current exists: 
      \item[-] Create a temp value that stores currents next node value
      \item[-] Set current.next equal to prev 
      \item[-] Set prev equal to current 
      \item[-] Set current equal to temp
      \item[-] Once this loop has finished, the current value will be None, and we need to return the new head, which is the last node that came before None
      \item[-] So we return prev


    \end{enumerate}
\end{enumerate}

\subsection{Cycle Detection Linked List}
\begin{enumerate}
  \item[] \textbf{Question:} Given the beginning of a linked list head, return true if there is a cycle in the linked list. Otherwise, return false.

There is a cycle in a linked list if at least one node in the list can be visited again by following the next pointer.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Set up a two pointers, one fast pointer and one slow pointer
      \item[-] The slow pointer will increment one each upon each iteration, the fast pointer will increment by two.
      \item[-] The idea is that the gap between the fast and slow pointer will gradually grow smaller and smaller until they point to the same node. This can only happen if there is a loop in the linked list
      \item[-] Set up both pointers to begin at the head node, if the head exists
      \item[-] Looping condition: While first pointer exists: first = first.next
      \item[-] Check if second.next and second.next.next exists, if so, second = second.next.next
      \item[-] Check if first = second. \textit{Note:} Must specifically check that first equals second and not their values. Checking if the node struct stored in memory is the same struct, not just the values!
    \end{enumerate}
\end{enumerate}

\subsection{Merge Two Sorted Lists}
\begin{enumerate}
  \item[] \textbf{Question:} You are given the heads of two sorted linked lists list1 and list2.

Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.

Return the head of the merged linked list.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Create a new head node that you will add two each list to, depending on which list has the smaller node when comparing the two
      \item[-] Set up a current node that will be assigned to the new head node
      \item[-] While looping condition: If list1 and list2, continue looping and comparing 
      \item[-] At the beginning of each loop, create a new node, and assign current at list1 or list2 to the new node depending on which one is smaller (increment list1 = list1.next or list2 = list2.next, depending on which was smaller)
      \item[-] Set the current.next to new node, and then increment current: current = current.next 
      \item[-] After while loop is finished, check if list1 or list2 still has any nodes, if either does, assign the remaining to the current.next
      \item[-] Return new-head.next (because new head is just a dummy node, and doesn't have any value)



    \end{enumerate}
\end{enumerate}




\end{document}

