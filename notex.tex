\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{enumitem}  

\title{Leetcode Notes and Practice}
\author{Sebastian Pucher}

\begin{document}
\maketitle                             


\tableofcontents

\newpage

\section{Hashing}
\subsection{Valid Anagram}
\begin{enumerate}
  \item[] \textbf{Question:} Given two strings s and t, return true if the two strings are anagrams of each other, otherwise return false
    \begin{enumerate}
      \item[-] Create two separate dictionaries
      \item[-] Loop through one of the input strings, add key letter or letter freq.
      \item[-] If dict are the same, return true
    \end{enumerate}
\end{enumerate}

\subsection{Twosum}
\begin{enumerate}
  \item[] \textbf{Question:} Given an array of integers nums and an integer target, return the indices i and j such that nums[i] + nums[j] == target and i != j
    \begin{enumerate}
      \item[-] Use a hashmap to store the index of each number in the array as the \textit{value}
      \item[-] On each iteration, check first to see if the difference between the target val and the current num is already stored in the hashmap
      \item[-] If it is, then return the value at that key (the index), as well as the current index i
      \item[-] If it's not, then add the current number and index to the hashmap 
      \item[-] \textbf{Key Idea: } Always check the existence between the target and the current number as a key in the hashmap first!
    \end{enumerate}
\end{enumerate}

\section{Two Pointers}
\subsection{Valid Palindrome}
\begin{enumerate}
  \item[] \textbf{Question:} Given a string s, return true if it is a palindrome, otherwise return false.

A palindrome is a string that reads the same forward and backward. It is also case-insensitive and ignores all non-alphanumeric characters.
    \begin{enumerate}
      \item[-] First change the string to all lowercase with .lower() function, this ensures case sensitive args are taken care of
      \item[-] Init left and right pointers to first and last characters
      \item[-] Do a check using \textbf{.isalnum()}. If it is \textit{not} alpha numeric, then increment or decrement the pointer and \textit{continue} through the loop
      \item[-] While left is less than or equal two right, compare the letters, if not the same, return false
      \item[-] increment / decrement left and right at bottom of loop
    \end{enumerate}
\end{enumerate}

\section{Sliding Window}
\subsection{Best Time to Buy and Sell Stocks}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an integer array prices where prices[i] is the price of NeetCoin on the ith day.

You may choose a single day to buy one NeetCoin and choose a different day in the future to sell it.

Return the maximum profit you can achieve. You may choose to not make any transactions, in which case the profit would be 0.
    \begin{enumerate}
      \item[-] \textbf{Buy low... sell high}: To achieve this, init two pointers, left wanting to find the low value in the arr, and right wanting to find the high value. Init left to first index, and right to second index in array
      \item[-] Begin looping through, so long as the right pointer is less than the length of the array
      \item[-] If the right value is ever less than the left value, then you have found a new low to sell at. \textit{So assign left equal to right, and increment right by one: continue the while loop}
      \item[-] Upon each iteration check if the difference between right and left values is greater than global profit (which is init to 0). If so, update profit 
    \end{enumerate}
\end{enumerate}

\section{Stack}
\subsection{Valid Parentheses}
\begin{enumerate}
  \item[] \textbf{Question:}You are given a string s consisting of the following characters: '(', ')', '\{', '\}', '[' and ']'.

The input string s is valid if and only if:
 -- Every open bracket is closed by the same type of close bracket.
 -- Open brackets are closed in the correct order.
 -- Every close bracket has a corresponding open bracket of the same type.

Return true if s is a valid string, and false otherwise.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Use a Stack to push open brackets, and pop closed brackets
      \item[-] Before iterating through each char of the string, create an array of valid open brackets, and an array of valid close brackets (same positioning in each) 
      \item[-] For each char, if the char is neither in each bracket array, return false. 
      \item[-] If the char is an open bracket, push to stack 
      \item[-] If the char is an close bracket, \textit{first check if the stack is non empty} then check to see if the last value on the stack is the corresponding open bracket to the current close bracket
      \item[-] Continue looping if it is, return false if it isn't
      \item[-] After the loop completes, ensure that the stack is empty, if it is, return true
        

    \end{enumerate}
\end{enumerate}

\section{Binary Search}
\subsection{Binary Search Recursive}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an array of distinct integers nums, sorted in ascending order, and an integer target.

Implement a function to search for target within nums. If it exists, then return its index, otherwise, return -1.

Your solution must run in O(logn) time.
    \begin{enumerate}
      \item[-] \textbf{Main idea:} To solve this problem recursively, you must keep track of left and right indices upon each recursive call
      \item[-] Initialize left to be index zero, and right to be last index (len(A) -1)
      \item[-] \textit{Base Case: }If left index equals right index, check if the value is in only position, if it is, return index, else return -1
      \item[-] If left doesn't equal right, find the mid index, and compare target value to value at middle index
      \item[-] If it equals the middle index, return
      \item[-] If it's greater than the middle index, recurse, left = middle index + 1
      \item[-] If it's less than the middle index, recurse, right = middle index - 1
      \item[-] \textbf{If parameters don't use left and right, you'll have to add them initially as none as defaults, then set them before recursing}

    \end{enumerate}
\end{enumerate}
\subsection{Binary Search Iterative}
\begin{enumerate}
  \item[] \textbf{Question:}  You are given an array of distinct integers nums, sorted in ascending order, and an integer target.

Implement a function to search for target within nums. If it exists, then return its index, otherwise, return -1.

Your solution must run in O(logn) time.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} To solve this problem iteratively, you must keep track of left and right indices and use a while loop
      \item[-] \textit{While loop Condition:} Loop so long as right is greater than or equal to the left index 
      \item[-] \textit{Base Case: } Within the while loop, calculate the mid index: \textbf{ mid = left + (diff between right and left / 2)}
      \item[-] If the target equals the mid index, return mid index
      \item[-] If left target is greater, then left becomes mid index +1
      \item[-] If it's less than the middle index right = middle index - 1
      \item[-] return -1 if not found (outside while loop)


    \end{enumerate}
\end{enumerate}
\subsection{Search 2D Matrix}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an m x n 2-D integer array matrix and an integer target.

  Each row in matrix is sorted in non-decreasing order.
  The first integer of every row is greater than the last integer of the previous row.
  Return true if target exists within matrix or false otherwise.

Can you write a solution that runs in O(log(m * n)) time?
    \begin{enumerate}
      \item[-] \textbf{Main idea:} Need to preform binary search \textit{twice}.
      \item[-] First binary search is done on the first column, which approximates where the actual value is 
      \item[-] To preform this first search, set up \textit{iterative} binary search as usual
      \item[-] \textbf{Edge Case:} When checking if the value is greater than the first in the row, must also check if the value is less than or EQUAL TO the last value in that row. This means that the value is \textit{in} that row.
      \item[-] If this condition is true, then you have found the row, and you can break from the first binary search loop. Store this row as the second array you will search over 
      \item[-] Now preform Binary Search a second time on this row, and return true or false depending on if the value was found or not

    \end{enumerate}
\end{enumerate}

\section{Linked Lists}

\subsection{Reverse Linked List}
\begin{enumerate}
  \item[] \textbf{Question:} Given the beginning of a singly linked list head, reverse the list, and return the new beginning of the list.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Set up a previous and current pointer node that will be used to reassign next pointer values
      \item[-] First check to see if the head node exists, if so, init prev to None, and current to the head 
      \item[-] While loop condition is while current exists: 
      \item[-] Create a temp value that stores currents next node value
      \item[-] Set current.next equal to prev 
      \item[-] Set prev equal to current 
      \item[-] Set current equal to temp
      \item[-] Once this loop has finished, the current value will be None, and we need to return the new head, which is the last node that came before None
      \item[-] So we return prev


    \end{enumerate}
\end{enumerate}

\subsection{Cycle Detection Linked List}
\begin{enumerate}
  \item[] \textbf{Question:} Given the beginning of a linked list head, return true if there is a cycle in the linked list. Otherwise, return false.

There is a cycle in a linked list if at least one node in the list can be visited again by following the next pointer.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Set up a two pointers, one fast pointer and one slow pointer
      \item[-] The slow pointer will increment one each upon each iteration, the fast pointer will increment by two.
      \item[-] The idea is that the gap between the fast and slow pointer will gradually grow smaller and smaller until they point to the same node. This can only happen if there is a loop in the linked list
      \item[-] Set up both pointers to begin at the head node, if the head exists
      \item[-] Looping condition: While first pointer exists: first = first.next
      \item[-] Check if second.next and second.next.next exists, if so, second = second.next.next
      \item[-] Check if first = second. \textit{Note:} Must specifically check that first equals second and not their values. Checking if the node struct stored in memory is the same struct, not just the values!
    \end{enumerate}
\end{enumerate}

\subsection{Merge Two Sorted Lists}
\begin{enumerate}
  \item[] \textbf{Question:} You are given the heads of two sorted linked lists list1 and list2.

Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.

Return the head of the merged linked list.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Create a new head node that you will add two each list to, depending on which list has the smaller node when comparing the two
      \item[-] Set up a current node that will be assigned to the new head node
      \item[-] While looping condition: If list1 and list2, continue looping and comparing 
      \item[-] At the beginning of each loop, create a new node, and assign current at list1 or list2 to the new node depending on which one is smaller (increment list1 = list1.next or list2 = list2.next, depending on which was smaller)
      \item[-] Set the current.next to new node, and then increment current: current = current.next 
      \item[-] After while loop is finished, check if list1 or list2 still has any nodes, if either does, assign the remaining to the current.next
      \item[-] Return new-head.next (because new head is just a dummy node, and doesn't have any value)



    \end{enumerate}
\end{enumerate}


\section{Trees}

\subsection{Invert Binary Tree}
\begin{enumerate}
  \item[] \textbf{Question:} You are given the root of a binary tree root. Invert the binary tree and return its root. 

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Preform a DFS on the tree, before exploring left and right children, swap the left and right 
      \item[-] In explore function, first check if the current node is None, this is the base case: If it is, simply return 
      \item[-] If not None, create a temp node, and swap the left and right children. Then explore left node, and explore right node
      \item[-] Explore function can be written as a part of the Solution Class
      \item[-] In main function, call explore on root, then return root


    \end{enumerate}
\end{enumerate}


\subsection{Max Depth of Binary Tree}
\begin{enumerate}
  \item[] \textbf{Question:} Given the root of a binary tree, return its depth.

The depth of a binary tree is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Preform a DFS on the tree, at each sub-problem, we want to pass up the max of the left and right at the current node
      \item[-] In explore function, first check if the current node is None, this is the base case: If it is, simply return 
      \item[-] If not None, recurse on the left and right parts of the tree and store the depths, then return upward the max(left, right)
      \item[-] Explore function can be written as a part of the Solution Class
      \item[-] In main function, return the call to explore


    \end{enumerate}
\end{enumerate}

\subsection{Max Diameter of Binary Tree}
\begin{enumerate}
  \item[] \textbf{Question:} The diameter of a binary tree is defined as the length of the longest path between any two nodes within the tree. The path does not necessarily have to pass through the root.

The length of a path between two nodes in a binary tree is the number of edges between the nodes.

Given the root of a binary tree root, return the diameter of the tree.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Create a attribute of the Solution class (called max diameter) then preform a DFS on the tree
      \item[-] The max diameter at each level is the longest number of edges spanning the left and right branches \textit{added together}.
      \item[-] The base case in this sense is if the current is NONE, it it is, RETURN -1, as there are no edges between the NONE node and the parent Node. 
      \item[-] At each sub-problem, recurse on the left and right sides (adding 1 to the return), and check if right added to left is greater than the member class var of max diameter. 
      \item[-] If it is, set max diameter. 
      \item[-] We want to pass up the longest span at any given node, which is the max between the left and right span
      \item[-] Call explore function from max diameter, and return the int value that explore returns. 

    \end{enumerate}
\end{enumerate}


\subsection{Balanced Binary Tree}
\begin{enumerate}
  \item[] \textbf{Question:} The depth of a binary tree is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} This question is a bit trickier, as you need to return a tuple, and not just a depth (like edge depth or node depth)
      \item[-] To begin preform a DFS on the tree. Start be defining the base case. If the node is NONE, return (0, True), as a None node is balanced. Because we are defining balance in terms of node height, and not edge height, base case starts at 0 and not -1.
      \item[-] Next, recurse on the left and right sub trees, and add one to the depth part of the tuple and store the True or False vale. 
      \item[-] Check if the distance between left and right is equal to 1 or 0, if it is, set a current balanced value equal to True. 
      \item[-] If this current balanced is True, and so are the left and right return T/F values are true, then return True upwards to the next subproblem. 
      \item[-] In terms of return depth upwards, we want to return the max depth between the left and right sub nodes.
      \item[-] So, return (max(left, right), (is-bal and left-bal and right-bal)) upwards
      \item[-] In main function, return the True or false value from the tuple as the answer


    \end{enumerate}
\end{enumerate}



\subsection{Same Binary Tree}
\begin{enumerate}
  \item[] \textbf{Question:} Given the roots of two binary trees p and q, return true if the trees are equivalent, otherwise return false.

Two binary trees are considered equivalent if they share the exact same structure and the nodes have the same values.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Use DFS to search through each tree, checking nodes along the way. If DFS is preformed in the same order for both trees, then they are the same
      \item[-] Two ways of solving this question: First is less buggy, but also less efficient. Idea is to create one explore call, and a visited array, and add nodes to the array upon being visited. Call explore twice, with two separate visited arrays, one for each tree
      \item[-] Check the arrays, if they are the same, return true, else return False. 
      \item[-] \textit{NOTE}: Doing it this way means you need to express the NULL Node in the array: In the base case, make sure to add None to the array, when you hit a None node.
      \item[-] \textbf{BETTER WAY:} A better way is to modify the explore function directly and have it accept two nodes.
      \item[-] Base case in this example becomes if \textit{both} nodes are None, return True upwards. If one node exists, and the other doesn't. Return False. 
      \item[-] Recurse on the left and right subtrees, comparing nodes as you go.

    \end{enumerate}
\end{enumerate}

\subsection{Subtree of Another Tree}
\begin{enumerate}
  \item[] \textbf{Question:} Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.

A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.


    \begin{enumerate}
      \item[-] \textbf{Main idea:} Use DFS to search through the main root tree. At each node, check if the current node val equals the target node val. If they do, then we can begin an is same tree check with this node as our new root. 
      \item[-] Checking if a tree is the same can be done in the two ways described in the previous question. We can use a DFS approach, and explore / check as we go, or create arrays that track the order in which the tree was traversed, and compare the arrays
      \item[-] \textit{SERIALIZE THE TWO TREES}: After banging my head against the wall, the best move it to serialize the lists.
      \item[-] Once this exploration and checking has been done, if the result is true, we must set a global variable to True, if it's not, we can  \textit{keep exploring} the main rooted tree. 
      \item[-] If the main rooted tree gets completely traversed, return false
      \item[-] Can create the root serizization in each stack frame: examine code for best practice in using serialization

    \end{enumerate}
\end{enumerate}

\section{Heap and Priority Queue}

\subsection{Kth Largest Element in a Stream}
\begin{enumerate}
  \item[] \textbf{Question:} 
    Design a class to find the kth largest integer in a stream of values, including duplicates. E.g. the 2nd largest from [1, 2, 3, 3] is 3. The stream is not necessarily sorted.

Implement the following methods:

 - constructor(int k, int[] nums) Initializes the object given an integer k and the stream of integers nums.\\
 - int add(int val) Adds the integer val to the stream and returns the kth largest integer in the stream.



    \begin{enumerate}
      \item[-] \textbf{Main idea:} Use a heap! By default, python has a built in heap library called heapq that uses min heaps
      \item[-] In the constructor set the value k to self.k 
      \item[-] Next, heapify the array, this is basically a free operation, as it takes liner time : O(n). \textit{NOTE:} Heapify happens in place (pass by reference), this means that we do not assign the array to a new variable. 
      \item[-] Next set the heapifyed array to another attribute variable (say streams).
      \item[-] In the addition function, first heappush() the value into the array. 
      \item[-] \textbf{heappush() time complexity: } Heappush adds the new values to the last value of the tree, the bubbles up. Bubbling up involves swapping nodes upward towards the root. This swapping can occur a max number of times thats equal to the height of the tree. So worst case is O(log(n)), time.
      \item[-] \textbf{heappop() time complexity: } Heappop is simular to heappush, as it swaps nodes. Only the root is swapped with a leaf node, the leaf node is removed and returned, and sink down swapping function is called on the root. This again can happen in O(log(n)) time. 
      \item[-] In our add function, after we've added the node, we can now heap pop so long as the length of the stream is greater than our kth value. In other words, keep popping until you've popped k times: return the kth element. Time complexity is O(klog(n))
    \end{enumerate}
\end{enumerate}









\end{document}

