\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{enumitem}  

\title{Leetcode Notes and Practice}
\author{Sebastian Pucher}

\begin{document}
\maketitle                             


\tableofcontents

\newpage

\section{Hashing}
\subsection{Valid Anagram}
\begin{enumerate}
  \item[] \textbf{Question:} Given two strings s and t, return true if the two strings are anagrams of each other, otherwise return false
    \begin{enumerate}
      \item[-] Create two separate dictionaries
      \item[-] Loop through one of the input strings, add key letter or letter freq.
      \item[-] If dict are the same, return true
    \end{enumerate}
\end{enumerate}

\subsection{Twosum}
\begin{enumerate}
  \item[] \textbf{Question:} Given an array of integers nums and an integer target, return the indices i and j such that nums[i] + nums[j] == target and i != j
    \begin{enumerate}
      \item[-] Use a hashmap to store the index of each number in the array as the \textit{value}
      \item[-] On each iteration, check first to see if the difference between the target val and the current num is already stored in the hashmap
      \item[-] If it is, then return the value at that key (the index), as well as the current index i
      \item[-] If it's not, then add the current number and index to the hashmap 
      \item[-] \textbf{Key Idea: } Always check the existence between the target and the current number as a key in the hashmap first!
    \end{enumerate}
\end{enumerate}

\subsection{Group Anagram}
\begin{enumerate}
  \item[] \textbf{Question:} Given an array of strings strs, group all anagrams together into sublists. You may return the output in any order.

An anagram is a string that contains the exact same characters as another string, but the order of the characters can be different.

    \begin{enumerate}
      \item[-] The main idea of this question is to use a hashmap, and use arrays as keys. In this case, the array would have 26 elements, set to 0 to start. 
      \item[-] Each of the 26 elements represents a letter a-z. The idea is that you count each letter when traversing through the string.  
      \item[-] Once you have counted all the letters, use tupple() to change the mutable array into an immutable key that can be used to store the word.
      \item[-] When adding it to the hash, first check to see if the key already exists. If so, add it to the array of other strs that have that mapping (add it to the values array at that key)
      \item[-] If it's not a key, add it as a new key, and add the string as an element of an array to the value at that position. 
      \item[-] Return the values of the hashmap. 
    \end{enumerate}
\end{enumerate}


\subsection{Single Number}
\begin{enumerate}
  \item[] \textbf{Question:} You are given a non-empty array of integers nums. Every integer appears twice except for one.

Return the integer that appears only once.

You must implement a solution with O(n) runtime complexity and use only  O(1) extra space. 


    \begin{enumerate}
      \item[-] Use a hash to keep track of numbers
      \item[-] If a number is not in the hash, add it in, if it is already in, then remove it.  
      \item[-] If you repeat this process for every number, then the only value left when you've traversed through the whole array will be the single number: So return the only key left
    \end{enumerate}
\end{enumerate}


\subsection{Encode / Decode}
\begin{enumerate}
  \item[] \textbf{Question:} Design an algorithm to encode a list of strings to a single string. The encoded string is then decoded back to the original list of strings. 

    \begin{enumerate}
      \item[-] The main idea here is to use two special characters that indicate the beginning and end of any given word  
      \item[-] Use the length of the string (an int) and some character like a \$ sign, to indicate the start of the part of the string to begin decoding. 
      \item[-] Loop through the encoded string, checking for these conditions, then building back out the original string
    \end{enumerate}
\end{enumerate}

\subsection{Product of Array Except Itself}
\begin{enumerate}
  \item[] \textbf{Question:} Given an integer array nums, return an array output where output[i] is the product of all the elements of nums except nums[i]. Each product is guaranteed to fit in a 32-bit integer.

Follow-up: Could you solve it in O(n) time without using the division operation?

    \begin{enumerate}
      \item[-] \textbf{Main Idea: } Create two hashmaps one that keeps the current product of all numbers up until a current index and another that keeps a current product of all the numbers after a current index until the end of the input array
      \item[-] This is like a memoization of all products before and after any given index. This will take 2 separate for loops
      \item[-] After you have done that, loop a final time and multiply the prefix and suffix product for each index. Store this in the answer array
    \end{enumerate}
\end{enumerate}


\subsection{Valid Sudoku}
\begin{enumerate}
  \item[] \textbf{Question:} You are given a 9 x 9 Sudoku board board. A Sudoku board is valid if the following rules are followed:

Each row must contain the digits 1-9 without duplicates.
Each column must contain the digits 1-9 without duplicates.
Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without duplicates.
Return true if the Sudoku board is valid, otherwise return false

    \begin{enumerate}
      \item[-] \textbf{Main Idea: } Create three separate hashmaps, one to track values in each row, each column and each segment of the Sudoku board. The segment hashmap relates to the 9 larger squared in the full board.
      \item[-] Loop through each cell and check if the value already exists in each hashmap or not. 
      \item[-] The keys of the segment hashmap will be (i//3) and (j//3). Floor divide each index by three to get the region of the segment.
      \item[-] Hard code all possible segment tuples into the starting hashmap before beginning the looping
    \end{enumerate}
\end{enumerate}



\section{Two Pointers}
\subsection{Valid Palindrome}
\begin{enumerate}
  \item[] \textbf{Question:} Given a string s, return true if it is a palindrome, otherwise return false.

A palindrome is a string that reads the same forward and backward. It is also case-insensitive and ignores all non-alphanumeric characters.
    \begin{enumerate}
      \item[-] First change the string to all lowercase with .lower() function, this ensures case sensitive args are taken care of
      \item[-] Init left and right pointers to first and last characters
      \item[-] Do a check using \textbf{.isalnum()}. If it is \textit{not} alpha numeric, then increment or decrement the pointer and \textit{continue} through the loop
      \item[-] While left is less than or equal two right, compare the letters, if not the same, return false
      \item[-] increment / decrement left and right at bottom of loop
    \end{enumerate}
\end{enumerate}


\subsection{Two Sum II (Two Integer Sum)}
\begin{enumerate}
  \item[] \textbf{Question:} Given an array of integers numbers that is sorted in non-decreasing order.

Return the indices (1-indexed) of two numbers, [index1, index2], such that they add up to a given target number target and index1 < index2. Note that index1 and index2 cannot be equal, therefore you may not use the same element twice.

There will always be exactly one valid solution.

Your solution must use O(1) additional space.
    \begin{enumerate}
      \item[-] \textbf{Main idea: } Use two pointers, one at the beginning of the array, and one at the end
      \item[-] If the sum number at the two pointers added together is greater than the target, then this means that the current sum is two big, and we must \textit{decrement the right pointer}
      \item[-] Following this same logic, if the current sum between the two pointers is less than the target, then we must \textit{increment the left pointer}. 
      \item[-] Do this until sum == target, then return.
    \end{enumerate}
\end{enumerate}

\subsection{3 Sum}
\begin{enumerate}
  \item[] \textbf{Question:} Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] where nums[i] + nums[j] + nums[k] == 0, and the indices i, j and k are all distinct.

The output should not contain any duplicate triplets. You may return the output and the triplets in any order.

    \begin{enumerate}
      \item[-] \textbf{Main idea: } This question is very similar to Two Sum II: Main idea is to have two pointers, one at the beginning of the input array and one at the end of the input array. First step is to SORT the input array
      \item[-] We need the sum of these to equal another value in the array multiplied by negative 1. 
      \item[-] Start by attempting to find what two other numbers can sum to equal the value at index 0. 
      \item[-] As before, we increment the left pointer if the sum value needs to be greater, and decrement the right pointer if it needs to be smaller. Repeat until something is found
      \item[-] Repeat this process for every value in the original array: This takes $O(n^2)$ time.
    \end{enumerate}
\end{enumerate}


\subsection{Longest Consecutive Sequence}
\begin{enumerate}
  \item[] \textbf{Question:} Given an array of integers nums, return the length of the longest consecutive sequence of elements that can be formed.

A consecutive sequence is a sequence of elements in which each element is exactly 1 greater than the previous element. The elements do not have to be consecutive in the original array.

You must write an algorithm that runs in O(n) time.


    \begin{enumerate}
      \item[-] \textbf{Main idea: } Begin by sorting the Array: Start two pointers left and right at the beginning of the sorted array: left at 0, right at 1
      \item[-] Keep a local max, and a global max: begin looping through the array, at any point, if the number in the right position is greater than the left by one, update the local max
      \item[-] If the local max is ever greater than the global, set the greater to the local value.
      \item[-] If the numbers at the left and right value equal each other, add one to both, and continue looping

      \item[-] If the right pointer value is not greater than left by 1, reset local max, and set left = right
      \item[-] After looping has completed, return the global max

    \end{enumerate}
\end{enumerate}


\subsection{Valid Palindrome II}
\begin{enumerate}
  \item[] \textbf{Question:} You are given a string s, return true if the s can be a palindrome after deleting at most one character from it.

A palindrome is a string that reads the same forward and backward.

Note: Alphanumeric characters consist of letters (A-Z, a-z) and numbers (0-9).


    \begin{enumerate}
      \item[-] \textbf{Main idea: } Begin looping through the question as usual. Make sure to make the overall string lowercase and check if each current character is  alphanumeric. Once you hit a letter where the left and right pointers don't match eachother do the following: 
      \item[-] Create another isPal function, and check if starting at the left+1 OR right-1 values returns a valid pal
      \item[-] If either of the two cases returns true, then return True, else return False

    \end{enumerate}
\end{enumerate}


\subsection{Squares of a Sorted Array}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.


    \begin{enumerate}
      \item[-] \textbf{Main idea: } Use two pointers, start at beginning and end of the array.
      \item[-] If the squared value at the left is greater than the right, then add that value to the end of the output array, else end the right value to the end of the output array: repeat until output array is full 
      \item[-] NOTE: you can index from the end using -1, then continue decrementing that value

    \end{enumerate}
\end{enumerate}





\section{Sliding Window}
\subsection{Best Time to Buy and Sell Stocks}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an integer array prices where prices[i] is the price of NeetCoin on the ith day.

You may choose a single day to buy one NeetCoin and choose a different day in the future to sell it.

Return the maximum profit you can achieve. You may choose to not make any transactions, in which case the profit would be 0.
    \begin{enumerate}
      \item[-] \textbf{Buy low... sell high}: To achieve this, init two pointers, left wanting to find the low value in the arr, and right wanting to find the high value. Init left to first index, and right to second index in array
      \item[-] Begin looping through, so long as the right pointer is less than the length of the array
      \item[-] If the right value is ever less than the left value, then you have found a new low to sell at. \textit{So assign left equal to right, and increment right by one: continue the while loop}
      \item[-] Upon each iteration check if the difference between right and left values is greater than global profit (which is init to 0). If so, update profit 
    \end{enumerate}
\end{enumerate}

\subsection{Longest Substring Without Repeating Characters}
\begin{enumerate}
  \item[] \textbf{Question:} Given a string s, find the length of the longest substring without duplicate characters.

A substring is a contiguous sequence of characters within a string.

    \begin{enumerate}
      \item[-] \textbf{Main Idea: } This is a sliding window question. The idea is that you will have two pointers start at the beginning of the string, and increment the right pointer, so long as the next character hasn't already occurred in the substring
      \item[-] More formally: get a local max-len, as well as a global max-len. Begin by incrementing the right pointer and adding the char to some tracked char array, so long if it isn't in the char array already. 
      \item[-] If it is, then we need to \textit{increment the left pointer}, and remove whatever value the left pointer is at from our tracked chars arr or hashmap. When we remove a char, be sure to decrement our local max-len.
      \item[-] Keep incrementing left pointer and removing from array until we've removed the character that the right pointer was pointing at. Once at this point, we can now continue to increment the right pointer as above. 
      \item[-] When incrementing right pointer, always update the local max, and check if it's greater than the global max
      \item[-] Once the left pointer has reached the end of the string, stop and return the global max
    \end{enumerate}
\end{enumerate}


\subsection{Container With Most Water}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an integer array heights where heights[i] represents the height of the ith bar.

You may choose any two bars to form a container. Return the maximum amount of water a container can store.

    \begin{enumerate}
      \item[-] \textbf{Main Idea: } Sliding window question, start a pointer at the beginning and at the end.
      \item[-] Calculate the area using the smaller of the two. Update global max if needed.
      \item[-] Move either the left or right pointer towards the center of the array: Always move the smaller of the two length pointers forward.
      \item[-] If the lengths are the same, it doesn't matter which one you increment or decrement. 
      \item[-] After the pointer indexes equal each other, return the max area created.
    \end{enumerate}
\end{enumerate}

\subsection{Longest Repeating Character Replacement}
\begin{enumerate}
  \item[] \textbf{Question:} You are given a string s consisting of only uppercase english characters and an integer k. You can choose up to k characters of the string and replace them with any other uppercase English character.

After performing at most k replacements, return the length of the longest substring which contains only one distinct character.

    \begin{enumerate}
      \item[-] \textbf{Main Idea: } Sliding window question with a hashmap: Start two pointers at the beginning of the array. Begin incrementing the right pointer and updating the frequency of that character in the hashmap
      \item[-] Core idea: Find the most frequent value in that window range: see if you can make all k replacements to the character: if you can set the result / max to the length of the range of the window.
      \item[-] To find the max, simply take the max of all the values in the hashmap.  
      \item[-] If the you cannot make k replacements, update both the left and right pointer. Slide the full window over. Do this until the right pointer is less than the length of the array
    \end{enumerate}
\end{enumerate}


\subsection{Permutations in String}
\begin{enumerate}
  \item[] \textbf{Question:} You are given two strings s1 and s2.

Return true if s2 contains a permutation of s1, or false otherwise. That means if a permutation of s1 exists as a substring of s2, then return true.

Both strings only contain lowercase letters.

    \begin{enumerate}
      \item[-] \textbf{Main Idea: } Sliding window question that involves using a hashmap and re-assigning left and right pointers. 
      \item[-] Begin by storing all chars / frequencies of s1 into a hashmap
      \item[-] Now init two pointers left and right at index zero of s1: the idea is that we well slide these pointers through the string and check if the window has the same hash count as the s1 hash
      \item[-] Begin by checking if the current character at the right pointer is in the keys of the first hash, if it is, then add one to this hash, and increment the right pointer. 
      \item[-] If at any point while looping through, the hash maps equal each other, return true
      \item[-] If the current right value is not in the hash map, then increment the left pointer once, and set the right pointer equal to the left pointer. Also reset the s2 hashmap
      \item[-] If the count of the right pointer is greater than the count at that value in s1, then slide and remove values at the left pointer, until the frequencies are the same.
      \item[-] If the right pointer reaches the end and there are no matches, return False
    \end{enumerate}
\end{enumerate}




\section{Stack}
\subsection{Valid Parentheses}
\begin{enumerate}
  \item[] \textbf{Question:}You are given a string s consisting of the following characters: '(', ')', '\{', '\}', '[' and ']'.

The input string s is valid if and only if:
 -- Every open bracket is closed by the same type of close bracket.
 -- Open brackets are closed in the correct order.
 -- Every close bracket has a corresponding open bracket of the same type.

Return true if s is a valid string, and false otherwise.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Use a Stack to push open brackets, and pop closed brackets
      \item[-] Before iterating through each char of the string, create an array of valid open brackets, and an array of valid close brackets (same positioning in each) 
      \item[-] For each char, if the char is neither in each bracket array, return false. 
      \item[-] If the char is an open bracket, push to stack 
      \item[-] If the char is an close bracket, \textit{first check if the stack is non empty} then check to see if the last value on the stack is the corresponding open bracket to the current close bracket
      \item[-] Continue looping if it is, return false if it isn't
      \item[-] After the loop completes, ensure that the stack is empty, if it is, return true

    \end{enumerate}
\end{enumerate}

\subsection{Min Stack}
\begin{enumerate}
  \item[] \textbf{Question:} Design a stack class that supports the push, pop, top, and getMin operations.

-- MinStack() initializes the stack object.
-- void push(int val) pushes the element val onto the stack.
-- void pop() removes the element on the top of the stack.
-- int top() gets the top element of the stack.
-- int getMin() retrieves the minimum element in the stack.

\textbf{Each function should run in O(1) time.}
    
    \begin{enumerate}
      \item[-] \textbf{Main idea:} This question is very easy except for returning the min in O(1) time. The idea here is to use another internal stack to keep track of all mins, as they are added.
      \item[-] We can also set up another class var called current min. This is the value that we actually return when getMin() function is called. 
      \item[-] Using internal stack to keep track of min goes as follows: if a new added value is less than the current min, then update the new current min to this value, as well as add this value to the internal min stack 
      \item[-] If we pop the value, and it is the current min, then we need to pop the value from both the regular stack, as well as the min stack, and set the new current min to the top (last) value in the min stack. If the min stack is empty, just set the current min to NONE (current min will be init as NONE).
    \end{enumerate}
\end{enumerate}

\subsection{Reverse Polish Notation}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an array of strings tokens that represents a valid arithmetic expression in Reverse Polish Notation.

Return the integer that represents the evaluation of the expression.

The operands may be integers or the results of other operations.
The operators include '+', '-', '*', and '/'.
Assume that division between integers always truncates toward zero.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} This question implements a stack: Loop through the array and add the numbers to the stack: if once you hit an operation over a number, then pop the last two elements of the stack, and preform that operation on them
      \item[-] Make sure you preform the operation in the correct order!
      \item[-] Once you have preformed the operation, push the result back into the stack and continue 
      \item[-] Repeat until the stack is of length 1: the last element left in the stack is the answer
    \end{enumerate}
\end{enumerate}


\subsection{Daily Temperatures}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an array of integers temperatures where temperatures[i] represents the daily temperatures on the ith day.

Return an array result where result[i] is the number of days after the ith day before a warmer temperature appears on a future day. If there is no day in the future where a warmer temperature will appear for the ith day, set result[i] to 0 instead.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} This uses the idea of a monotonic stack: this means that the elements will be ordered in strictly increasing or decreasing order
      \item[-] Keep a stack that stores both the temperature and index for all days in the array.
      \item[-] While the length of the stack is greater than zero, and the last day is cooler than the current day, pop the last element out of the stack. Store the answer as the result of subtracting the index of the element just popped and the index i
      \item[-] If the current element while looping through the array is smaller than the previous, add it to the stack
      \item[-] Essentially: Loop through all items once: if the item is smaller than the last element on the stack, then just add it to the stack. If it's larger, then pop the last value, and the answer at the last value is the difference between the indices.

    \end{enumerate}
\end{enumerate}


\subsection{Remove Adjacent Duplicates in String}
\begin{enumerate}
  \item[] \textbf{Question:} You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.

We repeatedly make duplicate removals on s until we no longer can.

Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.

 

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Use a stack! Add to the stack so long as the last element in the stack doesn't equal the current element that you want to push in. If it does, pop out the last value
      \item[-] After done iterating through the string, convert the stack (list) to a string, and return the string
      \item[-] 

    \end{enumerate}
\end{enumerate}







\section{Binary Search}
\subsection{Binary Search Recursive}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an array of distinct integers nums, sorted in ascending order, and an integer target.

Implement a function to search for target within nums. If it exists, then return its index, otherwise, return -1.

Your solution must run in O(logn) time.
    \begin{enumerate}
      \item[-] \textbf{Main idea:} To solve this problem recursively, you must keep track of left and right indices upon each recursive call
      \item[-] Initialize left to be index zero, and right to be last index (len(A) -1)
      \item[-] \textit{Base Case: }If left index equals right index, check if the value is in only position, if it is, return index, else return -1
      \item[-] If left doesn't equal right, find the mid index, and compare target value to value at middle index
      \item[-] If it equals the middle index, return
      \item[-] If it's greater than the middle index, recurse, left = middle index + 1
      \item[-] If it's less than the middle index, recurse, right = middle index - 1
      \item[-] \textbf{If parameters don't use left and right, you'll have to add them initially as none as defaults, then set them before recursing}

    \end{enumerate}
\end{enumerate}

\subsection{Binary Search Iterative}
\begin{enumerate}
  \item[] \textbf{Question:}  You are given an array of distinct integers nums, sorted in ascending order, and an integer target.

Implement a function to search for target within nums. If it exists, then return its index, otherwise, return -1.

Your solution must run in O(logn) time.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} To solve this problem iteratively, you must keep track of left and right indices and use a while loop
      \item[-] \textit{While loop Condition:} Loop so long as right is greater than or equal to the left index 
      \item[-] \textit{Base Case: } Within the while loop, calculate the mid index: \textbf{ mid = left + (diff between right and left / 2)}
      \item[-] If the target equals the mid index, return mid index
      \item[-] If left target is greater, then left becomes mid index +1
      \item[-] If it's less than the middle index right = middle index - 1
      \item[-] return -1 if not found (outside while loop)


    \end{enumerate}
\end{enumerate}



\subsection{Search 2D Matrix}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an m x n 2-D integer array matrix and an integer target.

  Each row in matrix is sorted in non-decreasing order.
  The first integer of every row is greater than the last integer of the previous row.
  Return true if target exists within matrix or false otherwise.

Can you write a solution that runs in O(log(m * n)) time?
    \begin{enumerate}
      \item[-] \textbf{Main idea:} Need to preform binary search \textit{twice}.
      \item[-] First binary search is done on the first column, which approximates where the actual value is 
      \item[-] To preform this first search, set up \textit{iterative} binary search as usual
      \item[-] \textbf{Edge Case:} When checking if the value is greater than the first in the row, must also check if the value is less than or EQUAL TO the last value in that row. This means that the value is \textit{in} that row.
      \item[-] If this condition is true, then you have found the row, and you can break from the first binary search loop. Store this row as the second array you will search over 
      \item[-] Now preform Binary Search a second time on this row, and return true or false depending on if the value was found or not

    \end{enumerate}
\end{enumerate}


\subsection{Koko eats Bananas}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an integer array piles where piles[i] is the number of bananas in the ith pile. You are also given an integer h, which represents the number of hours you have to eat all the bananas.

You may decide your bananas-per-hour eating rate of k. Each hour, you may choose a pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, you may finish eating the pile but you can not eat from another pile in the same hour.

Return the minimum integer k such that you can eat all the bananas within h hours.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} The hardest part of this question is knowing what to preform a binary search on, as we need to find the minimum integer k such that all bananas can be eaten within h hours. In this case, the max that k can be is the largest pile.
      \item[-] \textit{Simplified Solution:} Preform binary search from k = 1 to max pile amount in banana piles: In other words, preform binary search on [1, max(piles)].
      \item[-] In this case, we start at the half way pile. For this k value, check to see if all the bananas can be completed with this rate.
      \item[-] If it cannot, this k value is too small, and we need to retry with a new larger k. So preform binary search on the upper half. 
      \item[-] If all the values can be completed in this time, this is a valid k, but it isn't necessarily the \textit{smallest} k value. So we need to preform binary search again anyway on the left side of the array. 
      \item[-] If the smaller value doesn't work, then return the current min. If it does, repeat until the current min is the smallest working one.

    \end{enumerate}
\end{enumerate}




\section{Linked Lists}

\subsection{Reverse Linked List}
\begin{enumerate}
  \item[] \textbf{Question:} Given the beginning of a singly linked list head, reverse the list, and return the new beginning of the list.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Set up a previous and current pointer node that will be used to reassign next pointer values
      \item[-] First check to see if the head node exists, if so, init prev to None, and current to the head 
      \item[-] While loop condition is while current exists: 
      \item[-] Create a temp value that stores currents next node value
      \item[-] Set current.next equal to prev 
      \item[-] Set prev equal to current 
      \item[-] Set current equal to temp
      \item[-] Once this loop has finished, the current value will be None, and we need to return the new head, which is the last node that came before None
      \item[-] So we return prev


    \end{enumerate}
\end{enumerate}

\subsection{Cycle Detection Linked List}
\begin{enumerate}
  \item[] \textbf{Question:} Given the beginning of a linked list head, return true if there is a cycle in the linked list. Otherwise, return false.

There is a cycle in a linked list if at least one node in the list can be visited again by following the next pointer.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Set up a two pointers, one fast pointer and one slow pointer
      \item[-] The slow pointer will increment one each upon each iteration, the fast pointer will increment by two.
      \item[-] The idea is that the gap between the fast and slow pointer will gradually grow smaller and smaller until they point to the same node. This can only happen if there is a loop in the linked list
      \item[-] Set up both pointers to begin at the head node, if the head exists
      \item[-] Looping condition: While first pointer exists: first = first.next
      \item[-] Check if second.next and second.next.next exists, if so, second = second.next.next
      \item[-] Check if first = second. \textit{Note:} Must specifically check that first equals second and not their values. Checking if the node struct stored in memory is the same struct, not just the values!
    \end{enumerate}
\end{enumerate}

\subsection{Merge Two Sorted Lists}
\begin{enumerate}
  \item[] \textbf{Question:} You are given the heads of two sorted linked lists list1 and list2.

Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.

Return the head of the merged linked list.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Create a new head node that you will add two each list to, depending on which list has the smaller node when comparing the two
      \item[-] Set up a current node that will be assigned to the new head node
      \item[-] While looping condition: If list1 and list2, continue looping and comparing 
      \item[-] At the beginning of each loop, create a new node, and assign current at list1 or list2 to the new node depending on which one is smaller (increment list1 = list1.next or list2 = list2.next, depending on which was smaller)
      \item[-] Set the current.next to new node, and then increment current: current = current.next 
      \item[-] After while loop is finished, check if list1 or list2 still has any nodes, if either does, assign the remaining to the current.next
      \item[-] Return new-head.next (because new head is just a dummy node, and doesn't have any value)

    \end{enumerate}
\end{enumerate}

\subsection{Remove Nth Node From End of List}
\begin{enumerate}
  \item[] \textbf{Question:} You are given the beginning of a linked list head, and an integer n.

Remove the nth node from the end of the list and return the beginning of the list.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Use a dummy node, and count all nodes in the list. After you have counted all the nodes, reset the current node to the beginning of the linked list (dummy node).
      \item[-] Now, knowing how many nodes there are total, we can loop to the NODECOUNT - nth node. Once we have arrived at this node, we can delete the Nth node by setting the current to current.next.next

    \end{enumerate}
\end{enumerate}

\subsection{Copy Linked List with Random Pointer}
\begin{enumerate}
  \item[] \textbf{Question:} You are given the head of a linked list of length n. Unlike a singly linked list, each node contains an additional pointer random, which may point to any node in the list, or null.

Create a deep copy of the list.

The deep copy should consist of exactly n new nodes, each including:

\begin{enumerate}
  \item[-] The original value val of the copied node
  \item[-] A next pointer to the new node corresponding to the next pointer of the original node
  \item[-] A random pointer to the new node corresponding to the random pointer of the original node
  \item[-] Note: None of the pointers in the new list should point to nodes in the original list.
\end{enumerate}

Return the head of the copied linked list.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Begin by creating a hashmap, where the key is the original node (pointer), and the value is a new node.
      \item[-] Begin by looping through the original list, creating new nodes (and adding the value to each node)
      \item[-] Now that you have all of the new nodes in the hashmap, loop through the original list again, and use the keys to determine where the random pointer should point to.  
      \item[-] Remember, the random pointer assignment should always point to a new copied node!
      \item[-] Edge cases: There is a chance that the random pointer points to None, or the current.next is none. Before assigning a node, check to see if the value in the original linked list is None or not. If it's node, simply assign it to None, if not, assign it following the structure of the Algorithm.

    \end{enumerate}
\end{enumerate}

\subsection{Add Two Numbers In Linked List}
\begin{enumerate}
  \item[] \textbf{Question:} You are given two non-empty linked lists, l1 and l2, where each represents a non-negative integer.

The digits are stored in reverse order, e.g. the number 123 is represented as 3 -> 2 -> 1 -> in the linked list.

Each of the nodes contains a single digit. You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Return the sum of the two numbers as a linked list.


    \begin{enumerate}
      \item[-] \textbf{Main idea:} Use a carry bit: loop through both linked lists so long as current in each exist, and the carry is not 1
      \item[-] In each iteration, if the first list exists, add its value to a current sum, if the second exists, add its value to a current sum, if the carry is 1, add the carry as well.
      \item[-] If the current sum is over 9, subtract 10, and add 1 to the carry. Repeat until all nodes from original list have been added.
      \item[-] Make sure to create nodes (and a dummy node to begin) as you go!

    \end{enumerate}
\end{enumerate}


\subsection{Find The Duplicate Number}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an array of integers nums containing n + 1 integers. Each integer in nums is in the range [1, n] inclusive.

Every integer appears exactly once, except for one integer which appears two or more times. Return the integer that appears more than once.

Can you solve the problem without modifying the array nums and using O(1) extra space?


    \begin{enumerate}
      \item[-] \textbf{Main idea:} This is a cycle detection problem: the idea is that you use the values in the array as indicate into other parts of the array: if you arrive at the same spot using fast and slow pointers, then you've hit an interception!
      \item[-] Once you've hit an interception, you must create a new pointer and assign it to the initial node.
      \item[-] Now increment the initial pointer, and one of the pointers at an interception until they intercept once more.
      \item[-] At this index, this is where the duplicate is!

    \end{enumerate}
\end{enumerate}




\section{Trees}

\subsection{Invert Binary Tree}
\begin{enumerate}
  \item[] \textbf{Question:} You are given the root of a binary tree root. Invert the binary tree and return its root. 

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Preform a DFS on the tree, before exploring left and right children, swap the left and right 
      \item[-] In explore function, first check if the current node is None, this is the base case: If it is, simply return 
      \item[-] If not None, create a temp node, and swap the left and right children. Then explore left node, and explore right node
      \item[-] Explore function can be written as a part of the Solution Class
      \item[-] In main function, call explore on root, then return root


    \end{enumerate}
\end{enumerate}


\subsection{Max Depth of Binary Tree}
\begin{enumerate}
  \item[] \textbf{Question:} Given the root of a binary tree, return its depth.

The depth of a binary tree is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Preform a DFS on the tree, at each sub-problem, we want to pass up the max of the left and right at the current node
      \item[-] In explore function, first check if the current node is None, this is the base case: If it is, simply return 
      \item[-] If not None, recurse on the left and right parts of the tree and store the depths, then return upward the max(left, right)
      \item[-] Explore function can be written as a part of the Solution Class
      \item[-] In main function, return the call to explore


    \end{enumerate}
\end{enumerate}

\subsection{Max Diameter of Binary Tree}
\begin{enumerate}
  \item[] \textbf{Question:} The diameter of a binary tree is defined as the length of the longest path between any two nodes within the tree. The path does not necessarily have to pass through the root.

The length of a path between two nodes in a binary tree is the number of edges between the nodes.

Given the root of a binary tree root, return the diameter of the tree.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Create a attribute of the Solution class (called max diameter) then preform a DFS on the tree
      \item[-] The max diameter at each level is the longest number of edges spanning the left and right branches \textit{added together}.
      \item[-] The base case in this sense is if the current is NONE, it it is, RETURN -1, as there are no edges between the NONE node and the parent Node. 
      \item[-] At each sub-problem, recurse on the left and right sides (adding 1 to the return), and check if right added to left is greater than the member class var of max diameter. 
      \item[-] If it is, set max diameter. 
      \item[-] We want to pass up the longest span at any given node, which is the max between the left and right span
      \item[-] Call explore function from max diameter, and return the int value that explore returns. 

    \end{enumerate}
\end{enumerate}


\subsection{Balanced Binary Tree}
\begin{enumerate}
  \item[] \textbf{Question:} The depth of a binary tree is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} This question is a bit trickier, as you need to return a tuple, and not just a depth (like edge depth or node depth)
      \item[-] To begin preform a DFS on the tree. Start be defining the base case. If the node is NONE, return (0, True), as a None node is balanced. Because we are defining balance in terms of node height, and not edge height, base case starts at 0 and not -1.
      \item[-] Next, recurse on the left and right sub trees, and add one to the depth part of the tuple and store the True or False vale. 
      \item[-] Check if the distance between left and right is equal to 1 or 0, if it is, set a current balanced value equal to True. 
      \item[-] If this current balanced is True, and so are the left and right return T/F values are true, then return True upwards to the next subproblem. 
      \item[-] In terms of return depth upwards, we want to return the max depth between the left and right sub nodes.
      \item[-] So, return (max(left, right), (is-bal and left-bal and right-bal)) upwards
      \item[-] In main function, return the True or false value from the tuple as the answer


    \end{enumerate}
\end{enumerate}



\subsection{Same Binary Tree}
\begin{enumerate}
  \item[] \textbf{Question:} Given the roots of two binary trees p and q, return true if the trees are equivalent, otherwise return false.

Two binary trees are considered equivalent if they share the exact same structure and the nodes have the same values.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Use DFS to search through each tree, checking nodes along the way. If DFS is preformed in the same order for both trees, then they are the same
      \item[-] Two ways of solving this question: First is less buggy, but also less efficient. Idea is to create one explore call, and a visited array, and add nodes to the array upon being visited. Call explore twice, with two separate visited arrays, one for each tree
      \item[-] Check the arrays, if they are the same, return true, else return False. 
      \item[-] \textit{NOTE}: Doing it this way means you need to express the NULL Node in the array: In the base case, make sure to add None to the array, when you hit a None node.
      \item[-] \textbf{BETTER WAY:} A better way is to modify the explore function directly and have it accept two nodes.
      \item[-] Base case in this example becomes if \textit{both} nodes are None, return True upwards. If one node exists, and the other doesn't. Return False. 
      \item[-] Recurse on the left and right subtrees, comparing nodes as you go.

    \end{enumerate}
\end{enumerate}

\subsection{Subtree of Another Tree}
\begin{enumerate}
  \item[] \textbf{Question:} Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.

A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.


    \begin{enumerate}
      \item[-] \textbf{Main idea:} Use DFS to search through the main root tree. At each node, check if the current node val equals the target node val. If they do, then we can begin an is same tree check with this node as our new root. 
      \item[-] Checking if a tree is the same can be done in the two ways described in the previous question. We can use a DFS approach, and explore / check as we go, or create arrays that track the order in which the tree was traversed, and compare the arrays
      \item[-] \textit{SERIALIZE THE TWO TREES}: After banging my head against the wall, the best move it to serialize the lists.
      \item[-] Once this exploration and checking has been done, if the result is true, we must set a global variable to True, if it's not, we can  \textit{keep exploring} the main rooted tree. 
      \item[-] If the main rooted tree gets completely traversed, return false
      \item[-] Can create the root serizization in each stack frame: examine code for best practice in using serialization

    \end{enumerate}
\end{enumerate}

\subsection{Binary Tree Level Order Traversal}
\begin{enumerate}
  \item[] \textbf{Question:} Given a binary tree root, return the level order traversal of it as a nested list, where each sublist contains the values of nodes at a particular level in the tree, from left to right. 

    \begin{enumerate}
      \item[-] \textbf{Main idea:} This question boils down to preforming breadth first search and assigning nodes a level number when preforming the traversal. 
      \item[-] To begin, set up a queue, because queues are used to preform BFS. Also set up a level number and assign level=0. 
      \item[-] Start by putting the root and level=0 in the queue as a tuple. Now preform BFS on the queue. 
      \item[-] Inside the explore function, if the current node has a left and right, add them to the queue as you normally would, but as a tuple with level+=1. More specifically add (current.left, level+=1) and (current.right, level+=1) to the queue. 
      \item[-] This will properly assign each node to a level. When returning back from BFS, simply group together all values that have the same level into an array. 

    \end{enumerate}
\end{enumerate}

\subsection{Right side view of binary Tree}
\begin{enumerate}
  \item[] \textbf{Question:} You are given the root of a binary tree. Return only the values of the nodes that are visible from the right side of the tree, ordered from top to bottom. 

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Traverse the tree with Breadth first search, as you go, index values based on depth (pair value with it's current depth)
      \item[-] After you have finished the traversal, loop through all elements. For any given element, if the next element in the array has a level thats one greater than the current, then you know that the current node is on right side view (add it to an array that tracks these nodes -> return array as answer)

    \end{enumerate}
\end{enumerate}

\subsection{Count Good Nodes in Binary Tree}
\begin{enumerate}
  \item[] \textbf{Question:} Within a binary tree, a node x is considered good if the path from the root of the tree to the node x contains no nodes with a value greater than the value of node x

Given the root of a binary tree root, return the number of good nodes within the tree.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Traverse the tree with DFS, add a global attribute count to the class
      \item[-] Start traversing but pass along a max value node: start the max value at negative infinity
      \item[-] As you traverse, if the current value is greater than or equal to the max value, add 1 to count, and pass the current value down up the recursion stack as the new max value: don't return anything recursively 

    \end{enumerate}
\end{enumerate}

\subsection{Validate Binary Search Tree}
\begin{enumerate}
  \item[] \textbf{Question:} Given the root of a binary tree, return true if it is a valid binary search tree, otherwise return false.

A valid binary search tree satisfies the following constraints:

The left subtree of every node contains only nodes with keys less than the node's key.
The right subtree of every node contains only nodes with keys greater than the node's key.
Both the left and right subtrees are also binary search trees.


    \begin{enumerate}
      \item[-] \textbf{Main idea:} Recall that a valid binary search tree is where at each sub tree, the left node's value is always less than the parent's value, and the right node's value is always greater than the parents
      \item[-] Recursively, we must check if all subtrees that came before are valid, and if the current left, right, and parent are valid.
      \item[-] Let's start with the base case, if the current Node is None, return the minimum and maximum value at this subtree (which are both None), and also if it's a valid BTS or not: In this case, it is! so return (NONE, NONE, True)
      \item[-] Recursively call of both left and right, and store left-min, left-max, and left-valid as values returned from the recursive call: do the same with the right values
      \item[-] Check first to see if either left-valid and right-valid are False, if so, return false upward.
      \item[-] If they are both true, then check if the current value is greater than max-left and less than the min-right, if so, then the current tree is valid
      \item[-] *****Always pass upward the largest value on the left side of the tree, and the smallest value on the right side of the Tree. This ensures that parent trees remain valid****
      \item[-]
    \end{enumerate}
\end{enumerate}


\subsection{Lowest Common Ancestor in Binary Tree}
\begin{enumerate}
  \item[] \textbf{Question:} Given a binary search tree (BST) where all node values are unique, and two nodes from the tree p and q, return the lowest common ancestor (LCA) of the two nodes.

The lowest common ancestor between two nodes p and q is the lowest node in a tree T such that both p and q as descendants. The ancestor is allowed to be a descendant of itself. 


    \begin{enumerate}
      \item[-] \textbf{Main idea:} This question is kinda tricky! The main idea is to find and return upwards through the tree nodes p and q when you find them. While doing this, check the ancestor condition
      \item[-] There are three different ancestor conditions: if the left and right nodes are p and q, then the current node is the LCA
      \item[-] If the current Node is p and the left or right is q, then LCQ is the p node
      \item[-] If the current Node is q and the left or right is p, then LCQ is the q node
      \item[-] Once you have found the LCA node, store it as a global variable, then begin returning None upwards
      \item[-] At the end, return the global LCA Node

    \end{enumerate}
\end{enumerate}




\section{Heap and Priority Queue}

\subsection{Kth Largest Element in a Stream}
\begin{enumerate}
  \item[] \textbf{Question:} 
    Design a class to find the kth largest integer in a stream of values, including duplicates. E.g. the 2nd largest from [1, 2, 3, 3] is 3. The stream is not necessarily sorted.

Implement the following methods:

 - constructor(int k, int[] nums) Initializes the object given an integer k and the stream of integers nums.\\
 - int add(int val) Adds the integer val to the stream and returns the kth largest integer in the stream.



    \begin{enumerate}
      \item[-] \textbf{Main idea:} Use a heap! By default, python has a built in heap library called heapq that uses min heaps
      \item[-] In the constructor set the value k to self.k 
      \item[-] Next, heapify the array, this is basically a free operation, as it takes liner time : O(n). \textit{NOTE:} Heapify happens in place (pass by reference), this means that we do not assign the array to a new variable. 
      \item[-] Next set the heapifyed array to another attribute variable (say streams).
      \item[-] In the addition function, first heappush() the value into the array. 
      \item[-] \textbf{heappush() time complexity: } Heappush adds the new values to the last value of the tree, the bubbles up. Bubbling up involves swapping nodes upward towards the root. This swapping can occur a max number of times thats equal to the height of the tree. So worst case is O(log(n)), time.
      \item[-] \textbf{heappop() time complexity: } Heappop is simular to heappush, as it swaps nodes. Only the root is swapped with a leaf node, the leaf node is removed and returned, and sink down swapping function is called on the root. This again can happen in O(log(n)) time. 
      \item[-] In our add function, after we've added the node, we can now heap pop so long as the length of the stream is greater than our kth value. In other words, keep popping until you've popped k times: return the kth element. Time complexity is O(klog(n))
    \end{enumerate}
\end{enumerate}


\subsection{Last Stone Weight}
\begin{enumerate}
  \item[] \textbf{Question:} 
    You are given an array of integers stones where stones[i] represents the weight of the ith stone.

We want to run a simulation on the stones as follows:

At each step we choose the two heaviest stones, with weight x and y and smash them together  
  \begin{enumerate}
    \item[-] If x == y, both stones are destroyed
    \item[-]  If x < y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.
    \item[-] Continue the simulation until there is no more than one stone remaining. 
\end{enumerate}
Return the weight of the last remaining stone or return 0 if none remain.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Use a heap! This is a max heap problem, so the hardest part about the solution is ensuring we're translating the question correctly while using our min heap. To begin, we can multiply every value by -1 in the array, then call heapify. 
      \item[-] In the simulation, we choose the two heaviest stones, which means the two most negative stones. So heappop twice, and set x and y equal to the return values. Loop and grab the two largest values so long as the length of the heap is greater than 1
      \item[-] Now check to see if both of the values are the same, if they are, continue to the next iteration (continue inside while loop)
      \item[-] If x < y, then we must be careful in translating this to logic in the question, this condition will only happen if x is actually greater than y due to the values being negative. If this is the case, then we need to add y back in with weight y-x. In this case, we will add y back in with weight x - y. To see this math work out, I suggest writing out a couple of values to see how the negative works.
      \item[-] Once the looping expression evals to false, check to see if there are 1 or None values left in the heap
      \item[-] If there are none, then return 0, else, return -1 * heap[0] - > remember to turn the negative back to positive!
    \end{enumerate}
\end{enumerate}


\subsection{K Closest Points to Origin}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an 2-D array points where points[i] = [xi, yi] represents the coordinates of a point on an X-Y axis plane. You are also given an integer k.

Return the k closest points to the origin (0, 0).

The distance between two points is defined as the Euclidean distance $(sqrt((x1 - x2)^2 + (y1 - y2)^2))$.

You may return the answer in any order.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Use a heap to store the distance values! Start by looping through all the points, and calculating the distances of each point. 
      \item[-] Once you've calculated the distance, store that distance in an array that you'll heapify
      \item[-] Also store the distance as the key in a hashmap: the values will be \textit{an array of all the (x,y) coordinates that form this distance}
      \item[-] Once you have heapifyed the distance array, begin heappopping and looking up a x,y values from the array of possible values.
      \item[-] Add each (x,y) value as an array to an answer array. Do this k times, then return the answer array
    \end{enumerate}
\end{enumerate}

\subsection{Kth Largest Element}
\begin{enumerate}
  \item[] \textbf{Question:} Given an unsorted array of integers nums and an integer k, return the kth largest element in the array.

By kth largest element, we mean the kth largest element in the sorted order, not the kth distinct element.

Follow-up: Can you solve it without sorting?

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Use a heap, heapify it, then loop k times and return the kth largest element
      \item[-] This requires multiplying every element in the array by -1 to start, because we implement heapq which is a min heap
      \item[-] This problem can also be solved traditionally with sorting
    \end{enumerate}
\end{enumerate}

\subsection{Task Scheduler}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an array of CPU tasks tasks, where tasks[i] is an uppercase english character from A to Z. You are also given an integer n.

Each CPU cycle allows the completion of a single task, and tasks may be completed in any order.

The only constraint is that identical tasks must be separated by at least n CPU cycles, to cooldown the CPU.

Return the minimum number of CPU cycles required to complete all tasks.


    \begin{enumerate}
      \item[-] \textbf{Main idea:} This question involves using both a heap and a queue to schedule tasks. The intuition is to use a max heap that always pops the task with the most elements. 
      \item[-] Begin by creating a hashmap with all the tasks as the keys, and the value being their frequencies (the number of times they will need to get scheduled). 
      \item[-] Begin by popping the first task, and adding that task, along with its expiring time, to the queue. 
      \item[-] When adding a to the queue, always add the time to live, along side the CURRENT TIME. 
      \item[-] After each iteration, always check if the front of the queue has an expiring time, if so, add it back to the stack.
      \item[-] When adding back to the stack, make sure to decrement the overall frequency.
      \item[-] Repeat until the stack and queue are empty. Return the global counter.
    \end{enumerate}
\end{enumerate}



\section{Graphs}

\subsection{Number of Islands}
\begin{enumerate}
  \item[] \textbf{Question:}Given a 2D grid grid where '1' represents land and '0' represents water, count and return the number of islands.

An island is formed by connecting adjacent lands horizontally or vertically and is surrounded by water. You may assume water is surrounding the grid (i.e., all the edges are water). 

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Preform a DFS on the graph using a visited nodes list. Explore all neighbor nodes of a starting node, so long as the neighbor has not been visited. 
      \item[-] We will wrap the DFS call in a for loop that loops through every node. Every time the explore call returns, we will += our island counter by the return call of explore (which will return 1 or 0). This is the value that we will eventually return.
      \item[-] Inside our explore function, we must first check to see if the node had a value 1 or 0, if its 0, simply 0
      \item[-] If the value is 1, then we can explore all of the nodes neighbors. 
      \item[-] We can fist built our another function that returns all the neighbors of the given node. We can then loop through this list, for every non-visited neighbor.
      \item[-] After we have finished the recursive calling, we can return 1 to the parent wrapper function. 
      \item[-] Now having finished exploring the graph, we can return the island counter. 
      \item[-] \textbf{Note:} I used a list of tuples (x,y) to store visited nodes, but there's probably a better way to do this. 
    \end{enumerate}
\end{enumerate}


\subsection{Max Area of Islands}
\begin{enumerate}
  \item[] \textbf{Question:} You are given a matrix grid where grid[i] is either a 0 (representing water) or 1 (representing land).

An island is defined as a group of 1's connected horizontally or vertically. You may assume all four edges of the grid are surrounded by water.

The area of an island is defined as the number of cells within the island.

Return the maximum area of an island in grid. If no island exists, return 0.


    \begin{enumerate}
      \item[-] \textbf{Main idea:} Preform a DFS on the graph using a visited nodes list. Explore all neighbor nodes of a starting node, so long as the neighbor has not been visited. 
      \item[-] We will wrap the DFS call in a for loop that loops through every node. Inside the explore call, we need to have an internal counter that adds to the area as we traverse. We then return that area back to the parent function, and test to see if its greater than whatever our current max area is. 
      \item[-] As for the other inland question, we can fist built another function that returns all the neighbors of the given node. We can then loop through this list, for every non-visited neighbor.
      \item[-] Once our main parent for loop has terminated, we should have counted all the island's areas, and found the largest.
      \item[-] \textbf{Note:} Recursively internally counting can get tricky, make sure you consider what you're passing up to the parent. One way of doing this is to have a local area number set to 1, then return that area upward when you do the recursive call. 
    \end{enumerate}
\end{enumerate}


\subsection{Deep Clone a Graph}
\begin{enumerate}
  \item[] \textbf{Question:} Given a node in a connected undirected graph, return a deep copy of the graph.

Each node in the graph contains an integer value and a list of its neighbors.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Start by creating a hashmap of new nodes, where the node val is the new, and a new initialized node is the value
      \item[-] Next, preform a DFS or BFS on the original graph: this uses a stack or queue per usual, only now, make sure to set the value + neighbor nodes of the new nodes in your hashmap as you traverse. 
      \item[-] Make sure you add each neighbor to the new node * But make sure you don't have duplicate neighbors!
    \end{enumerate}
\end{enumerate}

\subsection{Islands and Treasure}
\begin{enumerate}
  \item[] \textbf{Question:} You are given a mn 2D grid initialized with these three possible values:

\begin{enumerate}
  \item[-] -1 - A water cell that can not be traversed.
  \item[-] 0 - A treasure chest.
  \item[-] INF - A land cell that can be traversed. We use the integer: 2147483647 to represent INF.
\end{enumerate}

Fill each land cell with the distance to its nearest treasure chest. If a land cell cannot reach a treasure chest then the value should remain INF.

Assume the grid can only be traversed up, down, left, or right.

Modify the grid in-place.


    \begin{enumerate}
      \item[-] \textbf{Main idea:} This question is not bad: begin by setting up a bfs function: the main idea is that you'll loop through the grid, and anytime you hit a number, preform BFS on that value and see if you can find a treasure.
      \item[-] Within BFS, make sure you are counting levels: if you ever hit a 0, then return the level count
      \item[-] If you never hit a 0, return None from the BFS function, indicating that we do not need to change the value of this node
      \item[-] Remember that you can create a nice helper function to get all neighbors!
      \item[-] Whenever a -1 value is reached, simply do nothing, do not traverse or add to neighbor list
      \item[-] use tuples (i,j) to store nodes in visited list
    \end{enumerate}
\end{enumerate}


\subsection{Pacific and Atlantic Ocean}
\begin{enumerate}
  \item[] \textbf{Question:} You are given a rectangular island heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).

The islands borders the Pacific Ocean from the top and left sides, and borders the Atlantic Ocean from the bottom and right sides.

Water can flow in four directions (up, down, left, or right) from a cell to a neighboring cell with height equal or lower. Water can also flow into the ocean from cells adjacent to the ocean.

Find all cells where water can flow from that cell to both the Pacific and Atlantic oceans. Return it as a 2D list where each element is a list [r, c] representing the row and column of the cell. You may return the answer in any order.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Create two groups, nodes that are touching pacific water, and nodes that are touching atlantic water
      \item[-] For each pacific water node, do a DFS to find all neighbors, where each neighbor is valid if its value is GREATER than the current node. Do this for all nodes touching pacific, and keep track of them
      \item[-] Do the same for atlantic nodes, preform a DFS and check if each of these neighbors can reach the atlantic nodes.
      \item[-] After you have preformed each DFS, check to find the nodes in both groups. Nodes in both groups are the answer.
    \end{enumerate}
\end{enumerate}





\section{Advanced Graphs}

\subsection{Network Delay Time}
\begin{enumerate}
  \item[] \textbf{Question:} You are given a network of n directed nodes, labeled from 1 to n. You are also given times, a list of directed edges where times[i] = (ui, vi, ti).

\begin{enumerate}
  \item[-] ui is the source node (an integer from 1 to n)
  \item[-] vi is the target node (an integer from 1 to n)
  \item[-] ti is the time it takes for a signal to travel from the source to the target node (an integer greater than or equal to 0).

\end{enumerate}
You are also given an integer k, representing the node that we will send a signal from.

Return the minimum time it takes for all of the n nodes to receive the signal. If it is impossible for all the nodes to receive the signal, return -1 instead.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} This is a classic DIJKSTRAS ALGO approach. I'm going to walk through the best steps in order to implement DIJKSTRAS in python, because although you knew how to do this problem, implementing DIJKSTRAS correctly was actually really buggy and hard.
      \item[-] To begin, change whatever internal data structure they give you into an adjacency list. 
      \item[-] The adjacency list is a dictionary, where the key is a node, and the value is a tuple with the neighbor node (v) and the weight between (u,v). \textbf{NOTE:} Not every node will be in the adjacency list! This is as expected
      \item[-] Once you have created the adjacency list, we now need to create the distances dictionary that will keep track of the currently running distances to each node. To begin, set the start node k to distance 0. (Distance from k to itself is just 0). Next, for all the remaining nodes, set the distance to INF. (Will use math.inf, which requires importing math). 
      \item[-] Next, set up the min-heap that you will \textit{heappush and heappop from}. Put the starting tupple (0, k) in the min heap
      \item[-] Now start the main looping. While the length of the min heap isn't 0, pop the tuple with the smallest distance. Because this is a heap, just heappop.
      \item[-] Now that you have the current smallest, check to see if the current stored distance to this node is smaller than the current distance popped from the heap. If it is smaller, then we can continue in the loop, as there is already a shorter distance found to this node. 
      \item[-] If it's not smaller, then for every neighbor in the adjacency list of this node, we must preform the following check: distances[v] > curr-dist + w
      \item[-] if this is true, then we must update distance[v] to curr-dist + w, and then heappush this neighbor and weight into the min-heap
      \item[-] After the while loop has finished, and all nodes have been explored, we can check if any nodes were unreachable, in this case, if any nodes in the distances dictionary are math.inf, then return -1
      \item[-] If all distances are in the dictionary, then we must return the max of all the distances in the dictionary, this equal the min over all nodes that needed to be communicated to. This problem was kinda annoying to solve because I had to implement DIJKSTRAS for the first time but moving forward hopefully it's not too bad
    \end{enumerate}
\end{enumerate}



\section{One-Dimensional Dynamic Programming}

\subsection{Climbing Stairs}
\begin{enumerate}
  \item[] \textbf{Question:}You are given an integer n representing the number of steps to reach the top of a staircase. You can climb with either 1 or 2 steps at a time.

Return the number of distinct ways to climb to the top of the staircase.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} We can use \textbf{Memoization} to keep track of sub solutions to each part of the problem. 
      \item[-] \textbf{Subproblem:} At each step, the number of distinct ways that can be reached is the sum of the number of distinct ways that can be reached at steps n-1 and n-2. memo[n-1] + memo[n-2].
      \item[-] We can set our current memo value, to the sum of the precious two memo values. 
      \item[-] To begin this problem, (or any DP problem), always start by populating the memo with the base cases of the problem.
      \item[-] In this case, we populate our memo with   memo = {1:1, 2:2} 
      \item[-] At the beginning of our recursion, we will check to see if the current value step is in the memo, if it is, then we return that memo value. 
      \item[-] If not, we add a new entry to our memo that equals our sub problem: memo[n] = memo[n-1] + memo[n-2]. To do this, we first must check to make sure that memo[n-1] and memo[n-2] exist. If we're doing the top down approach, they won't, so we make a recursive call:  memo[n] = self.memoClimb(n-1, memo) + self.memoClimb(n-2, memo). 
      \item[-] We then return the memo[n] upward 
      \item[-] \textbf{Note:} This problem can also be done iteratively, and honestly probably is easier to do that way, I put both my solutions in the python file.
    \end{enumerate}
\end{enumerate}


\subsection{Min Cost Climbing Stairs}
\begin{enumerate}
  \item[] \textbf{Question:}
      You are given an array of integers cost where cost[i] is the cost of taking a step from the ith floor of a staircase. After paying the cost, you can step to either the (i + 1)th floor or the (i + 2)th floor.

      You may choose to start at the index 0 or the index 1 floor.

      Return the minimum cost to reach the top of the staircase, i.e. just past the last index in cost.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} We can use \textbf{Memoization} to keep track of sub solutions to each part of the problem. 
      \item[-] \textbf{Subproblem:} At each step, the minimal cost would be the cost to get to that current step, plus the min at steps n-1, n-2. : memo[step] = currentCost + min(self.memoStairs(step-1, cost, memo), self.memoStairs(step-2,cost, memo))
      \item[-] To begin this problem, (or any DP problem), always start by populating the memo with the base cases of the problem.
      \item[-] In this case, we populate our memo with the costs associated at steps 1 and 2
      \item[-] At the beginning of our recursion, we will check to see if the current value step is in the memo, if it is, then we return that memo value. 
      \item[-] If not, we add a new entry to our memo that equals our sub problem. 
      \item[-] Because we need to get to the last stair, the stair that doesn't have a value, we need to create a current cost variable that tracks the current values current cost. If the last stair is met, then the current cost will just equal 0. 
      \item[-] After all of the recursion has been done, we will return memo[step]
    \end{enumerate}
\end{enumerate}


\subsection{House Robber}
\begin{enumerate}
  \item[] \textbf{Question:}

You are given an integer array nums where nums[i] represents the amount of money the ith house has. The houses are arranged in a straight line, i.e. the ith house is the neighbor of the (i-1)th and (i+1)th house.

You are planning to rob money from the houses, but you cannot rob two adjacent houses because the security system will automatically alert the police if two adjacent houses were both broken into.

Return the maximum amount of money you can rob without alerting the police.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} We can use \textbf{Memoization} to keep track of sub solution: We can solve this one with bottom up approach.
      \item[-] \textbf{Subproblem:} At each step, to maximize profit, we need to consider the following:
      \item[-] SUB-PROBLEM max(house[i] + memo[i-2], memo[i-1])
      \item[-] Start our memo with the max at house 1, which is just house 1, and the max at house 2, which is equal to max(house[0], house[1])
      \item[-] After you have init the memo with the first two houses, preform the sub-problem check on values i=2 through n.
      \item[-] The result last element of the memo
    \end{enumerate}
\end{enumerate}

\subsection{House Robber II}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an integer array nums where nums[i] represents the amount of money the ith house has. The houses are arranged in a circle, i.e. the first house and the last house are neighbors.

You are planning to rob money from the houses, but you cannot rob two adjacent houses because the security system will automatically alert the police if two adjacent houses were both broken into.

Return the maximum amount of money you can rob without alerting the police.


    \begin{enumerate}
      \item[-] \textbf{Main idea:} We can use \textbf{Memoization} to keep track of sub solution: We can solve this one with bottom up approach.
      \item[-] \textbf{Subproblem:} The sub-problem is the same as house robber I, but we need to run the memo on two instances, since the input array is "circular".
      \item[-] SUB-PROBLEM max(house[i] + memo[i-2], memo[i-1])
      \item[-] Run the bottom up iteration on the input array from index i=1, to i= len(input-arr): *IGNORE THE FIRST HOUSE
      \item[-] Run the bottom up iteration on the input array from index i=0, to i=len(input-arr) -1: *IGNORE THE LAST HOUSE
      \item[-] After you have solved both instances, the solution to this problem is the max of both of these.
    \end{enumerate}
\end{enumerate}



\section{Two-Dimensional Dynamic Programming}
\subsection{Unique Paths}
\begin{enumerate}
  \item[] \textbf{Question:}
    There is an m x n grid where you are allowed to move either down or to the right at any point in time.

Given the two integers m and n, return the number of possible unique paths that can be taken from the top-left corner of the grid (grid[0][0]) to the bottom-right corner (grid[m - 1][n - 1]).

You may assume the output will fit in a 32-bit integer.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} This question is not bad at all. Consider the following: At any point on the grid, you only have two options, move down, or move to the right. The total number of ways to reach the current square is the sum between the number of ways you could move at the square down, plus the number of ways from the square at the right.
      \item[-] At each square, add the numbers of ways at grid[i+1][j] + grid[i][j+1]. This gives you the total number of ways at grid[i][j].
      \item[-] Say you are just to the left of the final state, in this case, you cannot add whats below, because it doesn't exist. To solve this, expand the rows and columns by one, and fill in these as 0. So now when you add from this "out of bounds row", you simply add zero. 
      \item[-] Start looping the last row, upwards toward the starting position. Make sure to mark the final node grid[m-1][n-1] equal to 1!
      \item[-] After you've looped from the bottom row upward to the top row, making sure to add the right and bottom cells as you go, the final total amount of ways is the numbers of ways at the starting element: grid[0][0]: this is the solution.
    \end{enumerate}
\end{enumerate}


\subsection{Longest Common Subsequence}
\begin{enumerate}
  \item[] \textbf{Question:} Given two strings text1 and text2, return the length of the longest common subsequence between the two strings if one exists, otherwise return 0.

A subsequence is a sequence that can be derived from the given sequence by deleting some or no elements without changing the relative order of the remaining characters.

For example, "cat" is a subsequence of "crabt".
A common subsequence of two strings is a subsequence that exists in both strings.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Use a grid to keep track of the summation of sub-problems: begin by Initializing a grid with a length one greater than the width and height of the input text: text1 and text2. Fill the full 2d array with zeros
      \item[-] Next, start at the postion [len(text1)-1][len(text2)-1] in the grid (bottom right corner, one row / col up)
      \item[-] at each position in the grid, check the following:
      \item[-] if text1[i] == text2[j] -> grid[i][j] = 1 + grid[i+1][j+1] 
      \item[-] else: grid[i][j] = max(grid[i+1][j], grid[i][j+1])
      \item[-] Loop through the grid backwards by row and column, repeating this, until you have iterated through the full thing
      \item[i] Once done, return the number (summation of all sub-problems) at grid[0][0] this is the answer
    \end{enumerate}
\end{enumerate}



\section{Backtracking}
\subsection{Subsets}
\begin{enumerate}
  \item[] \textbf{Question:} Given an array nums of unique integers, return all possible subsets of nums.

The solution set must not contain duplicate subsets. You may return the solution in any order.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} This is a backtracking question. Begin be defining a backtracking function that takes in an index, and a current path
      \item[-] The idea is that you'll either add the value at the current index to the current-path array, the recurse again: backtrack(index+1, current-path), or when that's done executing, pop the last value out, then recurse again using the same call
      \item[-] BASE CASE, if the index is ever greater than or equal to the length of the input array, then add the current path to the result array, and return

    \end{enumerate}
\end{enumerate}

\subsection{Combination Sum}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an array of distinct integers nums and a target integer target. Your task is to return a list of all unique combinations of nums where the chosen numbers sum to target.

The same number may be chosen from nums an unlimited number of times. Two combinations are the same if the frequency of each of the chosen numbers is the same, otherwise they are different.

You may return the combinations in any order and the order of the numbers in each combination can be in any order.


    \begin{enumerate}
      \item[-] \textbf{Main idea:} This is a backtracking question. The idea is to create a bfs that has two decisions. Begin by setting up the base case:
      \item[-] Within the BFS 
      \item[-] 
      \item[-] 
      \item[-] 

    \end{enumerate}
\end{enumerate}








\section{Greedy}
\subsection{Jump Game}
\begin{enumerate}
  \item[] \textbf{Question:}
  You are given an integer array nums where each element nums[i] indicates your maximum jump length at that position.

  Return true if you can reach the last index starting from index 0, or false otherwise.
    \begin{enumerate}
      \item[-] \textbf{Main idea:} This question is greedy: the trick is to \textbf{start at the end of the array and work toward the beginning of the array}. If you work backwards, and you know that the previous element can reach the next, then you set the previous to the new end. Keep repeating this until your "end point" becomes the beginning of the array. If this is the case, then return true
      \item[-] You can use two pointers, left and right. Start right pointer at the end of the array, and the left pointer at one less than right.
      \item[-] Keep and ongoing variable that tracks the distance between the left and right nodes. (This value starts at 1)
      \item[-] If the value at the left pointer is ever greater than the distance between the current left and right, then set the right to the current left, and reset the distance between back to 0. 
      \item[-] If not, then decrement the left variable, and add to the distance between.
      \item[-] If left index becomes zero, and the current right index doesn't also equal zero, then the last element was not reachable from the first element: if it is zero, then return true
    \end{enumerate}
\end{enumerate}

\subsection{Gas Station}
\begin{enumerate}
  \item[] \textbf{Question:}

   There are n gas stations along a circular route. You are given two integer arrays gas and cost where:
   \begin{enumerate}
     \item[-] gas[i] is the amount of gas at the ith station.
     \item[-] cost[i] is the amount of gas needed to travel from the ith station to the (i + 1)th station. (The last station is connected to the first station)

\end{enumerate}
You have a car that can store an unlimited amount of gas, but you begin the journey with an empty tank at one of the gas stations.

Return the starting gas station's index such that you can travel around the circuit once in the clockwise direction. If it's impossible, then return -1.

It's guaranteed that at most one solution exists.


    \begin{enumerate}
      \item[-] \textbf{Main idea:} Take the differences between the gas station positive amount, and the cost. Begin a tank counter variable that keeps track of the amount of gas in the tank. For each station, take the difference between the fill up amount, and the cost, and add it to the ongoing tank counter amount. Store this index that you started at as the first "potential solution index"
      \item[-] If the tank counter amount is ever negative, reset the "potential solution index" to be the next index, and also set the tank amount back to zero
      \item[-] Keep looping through the gas station array repeating this process: at the end of the loop, the index where the tank counter never went negative is the solution index.
      \item[-] \textit{Another thing to check first is if the summation of the gas array is greater than or equal to the summation of the cost array: if not, then return -1 as the solution is not possible}
    \end{enumerate}
\end{enumerate}

\subsection{Hand of Straights}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an integer array hand where hand[i] is the value written on the ith card and an integer groupSize.

You want to rearrange the cards into groups so that each group is of size groupSize, and card values are consecutively increasing by 1.

Return true if it's possible to rearrange the cards in this way, otherwise, return false.

    \begin{enumerate}
      \item[-] \textbf{Main idea:} At any point in time, the smallest card will always have to be the start of group.
      \item[-] Begin by storing all card values and frequencies into a hash map. Key is the card val, and the value is the frequency of the card. Once stored, start by popping the minimum key (smallest card val). 
      \item[-] Now that you have the smallest card, begin checking if the next subsequent card is in the hashmap: if it is, decrement that value, and continue incrementing up, until you have filled a group size. 
      \item[-] If at any point, you check to see if a value is in your hashmap to form a group, and it is not, return false.
      \item[-] After you have formed a group, start the process over, and pop the minimum from the hash-map, then repeat the process.
      \item[-] If the hashmap is empty, and all groups where made, then return true
      \item[-] You can also do a preliminary check to see if the number of cards is divisible the group size. If it's not, go ahead and return false
    \end{enumerate}
\end{enumerate}

\section{Math {\&} Geometry}
\subsection{Plus One}
\begin{enumerate}
  \item[] \textbf{Question:} You are given an integer array digits, where each digits[i] is the ith digit of a large integer. It is ordered from most significant to least significant digit, and it will not contain any leading zero.

Return the digits of the given integer after incrementing it by one.
  

    \begin{enumerate}
      \item[-] \textbf{Main idea:} Keep a carry bit that will be either 0 or 1 throughout the question. 
      \item[-] Begin by setting the carry bit to 1
      \item[-] Loop through the input array backwards. If carry is ever 1, then add the current value at i and 1 together. 
      \item[-] If the sum is greater than 9, then make the current position 0, and set the carry to 1, continue looping through
      \item[-] If the sum is less than or equal to 9, then simply make the result the current digit, and set the carry to 0.
      \item[-] After looping through all the values, if the carry bit == 1, then add [1] to the left side of the array (beginning)

    \end{enumerate}
\end{enumerate}





\end{document}

